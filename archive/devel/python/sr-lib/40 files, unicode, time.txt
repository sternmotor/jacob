#!/usr/bin/env python
# -*- coding: utf-8 -*-

#UNICODE
# default Python 2 encoding is 'ascii'
# decode early, unicode everywhere, encode late
s.decode('utf-8') # read from disc or user input
    * <type 'str'> to <type 'unicode'>
u.encode('utf-8') # when writing to disc or print
    * <type 'unicode'> to <type 'str'>


# replace everything not a-z0-9 by '_' after converting ÄÖÜäöüß 

def renice( name = None ):
    name1 = re.sub( '\\xf6', 'oe',  name.lower()  )
    name2 = re.sub( '\\xe4', 'ae',  name1  )
    name3 = re.sub( '\\xfc', 'ue',  name2  )
    name4 = re.sub( '\\xdf', 'ss',  name3  )
    return  re.sub( '[^a-z0-9]', '_',  name4  )




# touch a file
    # set time of existing file:
    os.utime( path, None)

    # create not existing file
    open(path, 'w').close()


# make sure line exists in file
    # make sure nobody is in sudoers file
    sudoers_line = """nobody ALL = NOPASSWD: /bin/ip route *""" 
    for line in open( SUDOERS_FILE, 'r' ).readlines():
        if line.find( sudoers_line ) > -1:
            break
    else:
        fh_sudoers = open( SUDOERS_FILE, 'a' )
        fh_sudoers.write( sudoers_line + "\n" )
        fh_sudoers.close()




# os.path
path = os.path.normpath(self.path)
    if os.path.isabs(path):
        path = path[1:]    # safe assumption due to normpath above


realpath(path)          # resolve symlinks
join(path1 path2)       # concentate proper path
splitext(path)          # get path extension
isfile(path)
isdir(path)
islink(path)
getcdw()                # get current work dir
chmod(path, mode)       # mode = 0744 or
                        # stat.S_IRUSR 
    
chown(path, uid, gid)   # numerical uid, gid!
makedirs(path, [mode]   
remove(path)
removedirs(path)
rmtree                  # recursively
rename(src, dst)        # rename 
move(src,dst)           # move recursively

listdir(path)           # all files in dir
glob.iglob('/tmp/*.tmp')     # generator for walking entries by shell glob
copy(src,dst)           # for files and dirs
copytree(src,dst[, symlinks])       # recursively

# split a path into dir and filename from full_path
(dirpath, filename) = os.path.split(full_path)
# get all members of path
path_parts = full_path.split( os.sep ) 



# test if file is accessible (may not work with acls on network file systems)
    if os.access("some-filename", os.W_OK)
    if os.access("some-filename", os.R_OK)
    if os.access("some-filename", os.X_OK)

# create pathes (mkpath)
    os.makedirs ( sPath )

# signal handling, temp/lock file
# signal handling, temp/lock file
#! /usr/local/bin/python
import os
import tempfile
import sys
import signal
t_path = ''
t_file = None
def cleanup(signal, frame):
    if t_path != '' and t_file != None:
        print 'Cleaning up temporary files ...'
        os.close(t_file)
        os.remove(t_path)
        print 'Done!'
        sys.exit(0)
    else:
        sys.exit(0)
signal.signal(signal.SIGHUP, cleanup)
signal.signal(signal.SIGINT, cleanup)
signal.signal(signal.SIGQUIT, cleanup)
signal.signal(signal.SIGTERM, cleanup)
try:
    t_path = tempfile.mktemp()
    t_file = os.open(t_path, os.O_CREAT | os.O_RDWR)
except IOError:
    print 'Error:  Couldn\'t create temp file.'
    sys.exit(0)
#
# always close and remove the temp file
# before you exit from script
cleanup(t_path, t_file)





# remove file, ignore non-existing file
try:
   os.unlink("file")
   except OSError, e:
      if e.errno != errno.ENOENT:
            raise

