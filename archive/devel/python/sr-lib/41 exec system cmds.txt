#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
def _is_exe( fpath ):
    return os.path.exists(fpath) and os.access(fpath, os.X_OK) and os.access(fpath, os.R_OK)


# run python from within bash
export source="hallo"

python <<END
                                                                                
import os                                                                       
                                                                                
print os.environ['source']                                                      
print "VVV", "$target"                                                          
                                                                                
END  
#
def _is_exe( fpath ):
    if os.path.exists(fpath) and os.access(fpath, os.X_OK):


error codes:

>>> import errno 
use like 
>>> errno.EPERM 
1
>>> print os.strerror(1)
Operation not permitted
    
# files 
errno.ENOENT        No such file or directory 
errno.EEXIST        File exists 
errno.ENOTDIR       Not a directory  
errno.EISDIR        Is a directory 
errno.ETXTBSY       Text file busy 
errno.ENAMETOOLONG  File name too long 
 
 
# io, memory, devices 
errno.EIO           I/O error 
errno.ENOMEM        Out of memory 
errno.ENOSPC        No space left on device 
errno.ENXIO         No such device or address 
errno.EROFS         Read-only file system 
errno.EDEADLOCK     File locking deadlock error 
errno.ENOBUFS       No buffer space available 
 
 
 
errno.ESRCH         No such process 
errno.EINTR         Interrupted system call 
errno.ETIME         Timer expired 
errno.EPERM         Operation not permitted 
errno.ELIBACC       Can not access a needed shared library 

 
# network 
errno.ESTALE        Stale NFS file handle 
errno.EHOSTUNREACH  No route to host 
errno.ENETUNREACH   Network is unreachable 
errno.ECONNABORTED  Software caused connection abort 
errno.ECONNRESET    Connection reset by peer 
errno.ETIMEDOUT     Connection timed out 
errno.ECONNREFUSED  Connection refused 
errno.EHOSTDOWN     Host is down 
errno.EFAULT        Bad address 
errno.ENONET        Machine is not on the network 
errno.ECOMM         Communication error on send  
errno.EPROTO        Protocol error   
errno.ENOTSOCK      Socket operation on non-socket 
errno.EDESTADDRREQ  Destination address required 
errno.EREMOTE       Object is remote  
 
# general 
errno.EACCES        Permission denied 
errno.EAGAIN        Try again 
errno.ENOSYS        Function not implemented 
errno.ENODATA       No data available 
errno.ENOPKG        Package not installed 

# wrapper module for getting a password from the user. Getting a password is accomplished differently on UNIX, Windows, and Mac OS platforms, but this code encapsulates all of those differences.


# Bind the name getpass to the appropriate function
try:
     import termios, TERMIOS
except ImportError:
     try:
          import msvcrt
     except ImportError:
          try:
               from EasyDialogs import AskPassword
          except ImportError:
               getpass = default_getpass
          else:
               getpass = AskPassword
     else:
          getpass = win_getpass
else:

getpass = unix_getpass

    # termios is a UNIX-specific module that provides low-level control over the input terminal. If this module is
    # not available (because it's not on your system, or your system doesn't support it), the import fails and Python
    # raises an ImportError, which you catch.
    # OK, you didn't have termios, so let's try msvcrt, which is a Windows-specific module that provides an
    # API to many useful functions in the Microsoft Visual C++ runtime services. If this import fails, Python will
    # raise an ImportError, which you catch.
    # If the first two didn't work, you try to import a function from EasyDialogs, which is a Mac OS-specific
    # module that provides functions to pop up dialog boxes of various types. Once again, if this import fails, Python
    # will raise an ImportError, which you catch.


# system plattform linux windows feststellen:
if sys.platform == 'linux2':


# system interaction
# print all environment variables known to script
>>> import os
>>> for k, v in os.environ.items():
...     print "%s=%s" % (k, v)


    for files_filter in [ os.path.join( dir, filter ) 
                          for filter in filters 
                          for dir in dirs 
                        ]:

# start system command (simple) read output
    for line in os.popen( "xm info").readlines():



# exit handler
# the functions registered via this module are not called when the program is killed by a signal, when a Python fatal internal error is detected, or when os._exit() is called. sys.exit() is ok. register multiple functions if you need to.
import atexit
def sichereEingaben(liste): 
    open("eingaben.txt", "w").writelines("\n".join(liste)) 

# Any optional arguments that are to be passed to func must be passed as arguments to register()
atexit.register(sichereEingaben, eingaben) 



# command line options
import sys
program_name = sys.argv[0]
arguments = sys.argv[1:]
count = len(arguments)



# parse options:

    minArgs = 5 # minimum number of expected arguments (for later use)
    parser = OptionParser(add_help_option = False)
    parser.add_option( '-g', '--group'      , dest='group'      )
    parser.add_option( '-m', '--module'     , dest='module'     )
    parser.add_option( '-F', '--config'     , dest='configFile' )
    parser.add_option( '-h', '--help'       , dest='help',    action='store_true' ) 
    # analyse command line options
    optList, optArgs = parser.parse_args(sys.argv[1:])


    # iterate over option - arg values:
    for opt in optList.__dict__.items():
        print opt

    # all options set: a
    a= [ opt[0] for opt in optList.__dict__.items() if opt[1] is not None ]

    if len(a) < minArgs:
        tod_und_teufel

# surpress subproccess output
    fsck = subprocess.Popen(
        [ "/sbin/e2fsck", "-y", disc_dev ]  ,
        stdout = open( os.devnull, 'w' )    ,
        stderr = open( os.devnull, 'w' )    ,
    )
    ec  = fsck.wait()
    


# signal handling, temp/lock file
#! /usr/local/bin/python
import os
import tempfile
import sys
import signal
t_path = ''
t_file = None
def cleanup(signal, frame):
    if t_path != '' and t_file != None:
        print 'Cleaning up temporary files ...'
        os.close(t_file)
        os.remove(t_path)
        print 'Done!'
        sys.exit(0)
    else:
        sys.exit(0)
signal.signal(signal.SIGHUP, cleanup)
signal.signal(signal.SIGINT, cleanup)
signal.signal(signal.SIGQUIT, cleanup)
signal.signal(signal.SIGTERM, cleanup)
try:
    t_path = tempfile.mktemp()
    t_file = os.open(t_path, os.O_CREAT | os.O_RDWR)
except IOError:
    print 'Error:  Couldn\'t create temp file.'
    sys.exit(0)
#
# always close and remove the temp file
# before you exit from script
cleanup(t_path, t_file)




# pexpect
        session = pexpect.spawn( self.RDIFF_EXE, options, timeout=timeout)
        while True:
            out = session.readline()
            if out == '':
                break
            else:
                log.info( out.rstrip() )
        session.close()
        print session.exitstatus
        print session.signalstatus

# handle password dialog via pexpect
child = pexpect.spawn('scp foo myname@host.example.com:.')
child.expect ('Password:')
child.sendline (mypassword)

