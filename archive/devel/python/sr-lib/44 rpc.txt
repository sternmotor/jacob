#!/usr/bin/env python
# -*- coding: utf-8 -*-
# xmlrpc server

from SimpleXMLRPCServer import SimpleXMLRPCServer
# Methoden , die der Server zur Verfuegung
# stellen soll :
class MyFuncs :
    def add ( self , x , y ):
          return x + y
    def sub ( self , x , y ):
          return x - y
# Erstelle und starte Server :
server = SimpleXMLRPCServer(("localhost", 8000))
server.register_instance(MyFuncs())
server.serve_forever()

# xmlrpc client
import xmlrpclib
s = xmlrpclib.Server("http://localhost:8000")
print s.add(2 ,3)
print s.sub(5 ,2)





# remote execution (assume remote rpyc running) - call any functions or classes available on those machines
# wrap with tlslite for security
>>> use rpyc
>>> connGlarp = rpyc.classic.connect("71.218.122.169")
>>> connGlarp.modules.os.uname()
('FreeBSD', 'antediluvian.glarp.com', '6.1-RELEASE',
'FreeBSD 6.1-RELEASE #0: Fri Jul 18 00:01:34 MDT 2008;
root@antediluvian.glarp.com:/usr/src/sys/i386/compile/ANTEDILUVIAN',
'i386')

# asynchronius calls (do something while server works)
asleep = rpyc.async(conn.modules.time.sleep)
resource = asleep(15)
# check if finished
>>> resource.ready # True, False


# run local code remotely: possible


# Classic mode is just a service that exposes everything on the remote system, but you can build services that expose just a few things in a small number of lines of code
import rpyc
class DoStuffService(rpyc.Service):
   def on_connect(self):
    "Do some things when a connection is made"
   def on_disconnect(self):
       "Do some things AFTER a connection is dropped"
   def exposed_func1(self, *args, **kws):
       "Do something useful and maybe return a value"
   def exposed_func2(self, *args, **kws):
       "Like func1, but do something different"

if __name__ == '__main__':
   rpyc.utils.server.ThreadedServer(DoStuffService).start()

# From a client, this service is just like the classic mode server, except all it exposes is the methods that are prefixed by exposed_ (minus the prefix). Trying to access other methods (such as builtin modules) will fail. So a client might look like this:
>>> import rpyc
>>> conn = rpyc.connect('dostuff.example.com')
>>> myval = conn.root.func1()   # Special 'root' of connection
>>> local_computation(myval)

