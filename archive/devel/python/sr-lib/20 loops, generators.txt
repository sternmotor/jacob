#!/usr/bin/env python
# -*- coding: utf-8 -*-



# for loop: else
for i in range (0 , 10 , 2):
   print i    # 0 , 2 , 4 , ... , 8
else :
   print " Schleife komplett durchlaufen . "


#If you need both the index and the item, use the enumerate function:

    for index, item in enumerate(L):
        print index, item

#If you need only the index, use range and len:

    for index in range(len(L)):
        print index

#The list object supports the iterator protocol. To explicitly create an iterator, use the built-in iter function:

    i = iter(L)
    item = i.next() # fetch first value
    item = i.next() # fetch second value


# switch
>>>def a(s):
>>> print s
>>>def switch(ch):
>>> try:
>>> {'1': lambda : a("one"),
>>> '2': lambda : a("two"),
>>> '3': lambda : a("three"),
>>> 'a': lambda : a("Letter a")
>>> }[ch]()
>>> except KeyError:
>>> a("Key not Found")
>>>switch('1')
one
>>>switch('a')
Letter a
>>>switch('b')
Key not Found


# speed up "for loops" 
example:
newlist = []
for word in oldlist:
    newlist.append(word.upper())

# fastest: (push from interpreter to C code)
newlist = map(str.upper, oldlist)

# safe memory: avoid the overhead of generating the entire list at once
newlist = (s.upper() for s in oldlist)
    
# if you need to have a for loop, speed up by * avoiding dot references * using local vars (much faster)
def iupperList( oldlist):
    upper = str.upper
    append = newlist.append
    for word in oldlist:
        yield(upper(word))

# iterator with condition
a = [ i**2 for i in range(10) if i != 4]


# iterators, generators

#Suppose we want a stream of positive random numbers less than one that obey a backward-looking constraint. Specifically, we want each successive number to be at least 0.4 more or less than the last one. Moreover, the stream itself is not infinite, but rather ends after a random number of steps. For the examples, we will simply end the stream when a number less than 0.1 is produced

# a) use a "static" function-local variable to remember things about the last invocation of a function
import random
def randomwalk_static(last=[1]):    # init the "static" var(s)
    rand = random.random()          # init a candidate value
    if last[0] < 0.1:               # threshhold terminator
        return None                 # end-of-stream flag
    while abs(last[0]-rand) < 0.4:  # look for usable candidate
        print '*',                  # display the rejection
        rand = random.random()      # new candidate
    last[0] = rand                  # update the "static" var
    return rand
# call like
num = randomwalk_static()
while num is not None:
    print num,
    num = randomwalk_static()

# b) use iterator
import random
class randomwalk_iter:
    def __init__(self):
        self.last = 1               # init the prior value
        self.rand = random.random() # init a candidate value
    def __iter__(self):
        return self                 # simplest iterator creation
    def next(self):
        if self.rand < 0.1:         # threshhold terminator
            raise StopIteration     # end of iteration
        else:                       # look for usable candidate
            while abs(self.last-self.rand) < 0.4:
                print '*',          # display the rejection
                self.rand = random.random() # new candidate
            self.last = self.rand   # update prior value
            return self.rand

# call like
for num in randomwalk_iter():
    print num,

# c) use generator
import random
def randomwalk_generator():
    last, rand = 1, random.random() # initialize candidate elements
    while rand > 0.1:               # threshhold terminator
        print '*',                  # display the rejection
        if abs(last-rand) >= 0.4:   # accept the number
            last = rand             # update prior value
            yield rand              # return AT THIS POINT
        rand = random.random()      # new candidate
    yield rand                      # return the final small element

# call like
for num in randomwalk_generator():
    print(num)
# or
gen = randomwalk_generator()
try:
    while 1: print gen.next(),
except StopIteration:
    pass



# iterator /generator within recursion

# call recursion    
def listChilds( parent_pid = None):
    ppid = validate.is_integer( parent_pid )
    for pid in recurse( ppid ):
        print pid 

# loop control
def recurse( ppid ):
    yield ppid
    pids = yieldChilds( ppid )
    for pid in pids:
        for pid in recurse( pid):
            yield pid

# atom operation
def yieldChilds( pid ):
    cmd = "ps --no-headers --ppid %d -o pid" % pid
    stdout = subprocess.Popen(
        cmd.split(), stdout=subprocess.PIPE
    ).stdout
    for line in stdout:
        yield( validate.is_integer( line ) )

