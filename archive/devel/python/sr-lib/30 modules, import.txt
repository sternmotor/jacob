#!/usr/bin/env python
# -*- coding: utf-8 -*-



# module file and  call structures YES:
    # simple case: one class in one module dir
    module/
    +-- __init__.py
    +-- module.py

    * __init__.py
      from module import *  

    * module.py
      __all__=['Class, Error']
      class Error(BaseException)
      class Class

    * call like
    import module
    try:
        a=module.Class
    except module.Error, emsg:
        ...

   
    # mutiple classes in one module dir
    module/
    +-- __init__.py
    +-- A.py
    +-- B.py

    * __init__.py
      from A import *  
      from B import *

    * A.py
      __all__=['ClassA, Error']
      class Error(BaseException)
      class ClassA

    * B.py
      __all__=['ClassB, Error']
      class Error(BaseException)
      class ClassB  

    * call like
    import module.A 
    try:
        b=module.A.ClassA
    except module.A.Error, emsg:
        ...





# call method by name in variable
    def handle_cmd(self, cmd=None):

        method_ref=getattr(self,cmd)
        method_ref()




# modules
# program doesn't run any faster when it is read from a .pyc or .pyo file than when it is read from a .py file; the only thing that's faster about .pyc or .pyo files is the speed with which they are loaded. 
if __name__ == '__main__':
    print 'Dieses Programm laeuft selbst'
else:
    print 'Ich werde von einem anderen Modul importiert'


# remove actual dir from search path
    sys.path.pop(0)



# module import syntax
from math import pi as PI , sin
from math import *

# module search path
sys.path()

# modules
top level commands are beeing executed at module import



# module import in inline code:
    avoid multiple calls to import (slows down execution),
    set some if - clause or try-exception to import only ones

