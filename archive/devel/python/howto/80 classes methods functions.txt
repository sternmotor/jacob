#!/usr/bin/env python
# -*- coding: utf-8 -*-


# dir returns a list of the attributes and methods of any object: modules, functions, strings, lists, dictionaries
# to find all the methods which work on a dictionary, do
>>> d = {}
>>> dir(d)
['clear', 'copy', 'get', 'has_key', 'items', 'keys', 'setdefault', 'update', 'values']

# functions are objects, too



# subclassing
# in case a method must be subclassed: define  spaceholder method in parent:
def subclass_me(self):
    raise NotImplementedError("Subclass must implement abstract method")



# getattr
returns a reference (handle) to any object, a reference to a handle *is* the function itself
getattr(li, "pop") # gets a reference to the pop method of the list, method name is a simple string

# call a method by name in variable:
    import amodule
    varstring='f'
    function=getattr(amodule,varstring)
    function()  

    # or
    def output(data, format="text"):
        # object(here: module), method(string)[, default string]) 
        output_function = getattr(statsout, "output_%s" % format, output_text)  
            return output_function(data)



# callable 
# takes any object and returns True if the object can be called, or False otherwise.


# inherit dynamically from multiple class
class Slave1(object):
    t1="1"
class Slave2(object):
    t2="2"

class MetaClass(type):
    def __new__(meta, classname, bases, classDict):
        bases = tuple([Slave1, Slave2])
        return type.__new__(meta, classname, bases, classDict)

class Master(object):
    __metaclass__ = MetaClass

m=Master()
print m.t1
print m.t2


# functions
info(spacing=15, object=odbchelper)
or 
info(15,odbchelper)


# lambda-functions
#  define one-line mini-functions on the fly, define a separate normal function and use that instead. I use them in places where I want to encapsulate specific, non-reusable code without littering my code with a lot of little one-line functions.

>>> def f(x):
...     return x*2
...
>>> f(3)
6
>>> g = lambda x: x*2
>>> g(3)
6


# nesting functions
# nested functions can be called only from the function in which it is defined


# *args, **kwargs
def __init__(self, filename, **kw):
    """ The constructor takes the filename and some options.

        backup -- boolean indicating whether you want a backup file
            (default is yes)
    """
    self.filename = filename
    self.do_backup = kw.get('backup', 1)

    self.stream = None
    self.basename, ext = os.path.splitext(self.filename)


# Beispiel mit klassen:

# elternklasse mit einigen defaults

class BwLimit:
    BS_START = 1 * 102
    BS_MAX   = 4 * 1024
    CHECK_INTERVAL = 600

    def __init__(self, check_interval=CHECK_INTERVAL, bs_start=BS_START, bs_max=BS_MAX , *args, **kwargs):


# child klasse
class PipeBwLimit(BwLimit):
    PIPE_BS_MAX   = 64 * 1024
    PIPE_BS_START = 4 * 1024 
    def __init__(self, bs_max=PIPE_BS_MAX, bs_start=PIPE_BS_START, *args, **kwargs):
        BwLimit.__init__(self,bs_max=bs_max, bs_start=bs_start, *args, **kwargs)


if __name__ == '__main__':
    pbwl = PipeBwLimit(bw_max = 1024)



# lists as positional parameters
>>> args = [3, 6, 2, 3]
>>> spam (*args)
3 6 2 3

# use dictionaries as keyword - parameters
>>> kwargs = {"c" : 5, "a" : 2, "b" : 4, "d" :1}
>>> spam (**kwargs)
2 4 5 1

# all together (mixed parameters)
def spam (* args, **kwargs):
    for i in args :
         print i
    for i in kwargs :
         print i, kwargs[i]

>>> spam (1, 2, c=3, d=4)
1
2
c 3
d 4



# classes
# inherit anchestor modules
from UserDict import UserDict
class FileInfo(UserDict):

# constructor - like first method
class FileInfo(UserDict):
    "store file metadata"
    def __init__(self, filename=None):      # override "constructor" class of UserDict class
        UserDict.__init__(self)             # call "constructor" of anchestor class
        self["name"] = filename             # assign the argument filename as the value of this object's name key

# Instantiating classes in Python is straightforward. To instantiate a class, simply call the class as if it were a function, passing the arguments that the __init__ method defines. The return value will be the newly created object.

# private objects
everything starting with "__"
# If you try to call a private method, Python will raise a slightly misleading exception, saying that the method does not exist. Of course it does exist, but it's private, so it's not accessible outside the class.


# modify "return value" for classes (what you get by calling c = ExampleClass() )
class ExampleClass:
    def __str__ ( self ):
        return "my return"
>>> print c 
"my return"

# class variables: * same value for each instance
class ExampleClass:
    anzahl = 0
    def __init__(self):
        self.__class__.anzahl += 1  # instances counter


# TODO
# properties, static methods, class methods, decorators 


# setup.py
# Install script for ConfigObj
# Copyright (C) 2005-2010 Michael Foord, Mark Andrews, Nicola Larosa
# E-mail: fuzzyman AT voidspace DOT org DOT uk
#         mark AT la-la DOT com
#         nico AT tekNico DOT net

# This software is licensed under the terms of the BSD license.
# http://www.voidspace.org.uk/python/license.shtml

import sys
from distutils.core import setup
from configobj import __version__ as VERSION

NAME = 'configobj'

MODULES = 'configobj', 'validate'

DESCRIPTION = 'Config file reading, writing and validation.'

URL = 'http://www.voidspace.org.uk/python/configobj.html'

DOWNLOAD_URL = "http://www.voidspace.org.uk/downloads/configobj-%s.zip" % VERSION

LONG_DESCRIPTION = """**ConfigObj** is a simple but powerful config file reader and writer: an *ini
file round tripper*. Its main feature is that it is very easy to use, with a
straightforward programmer's interface and a simple syntax for config files.
It has lots of other features though :

* Nested sections (subsections), to any level
* List values
* Multiple line values
* Full Unicode support
* String interpolation (substitution)
* Integrated with a powerful validation system

    - including automatic type checking/conversion
    - and allowing default values
    - repeated sections

* All comments in the file are preserved
* The order of keys/sections is preserved
* Powerful ``unrepr`` mode for storing/retrieving Python data-types

| Release 4.7.2 fixes several bugs in 4.7.1
| Release 4.7.1 fixes a bug with the deprecated options keyword in
| 4.7.0.
| Release 4.7.0 improves performance adds features for validation and
| fixes some bugs."""

CLASSIFIERS = [
    'Development Status :: 6 - Mature',
    'Intended Audience :: Developers',
    'License :: OSI Approved :: BSD License',
    'Programming Language :: Python',
    'Programming Language :: Python :: 2.3',
    'Programming Language :: Python :: 2.4',
    'Programming Language :: Python :: 2.5',
    'Programming Language :: Python :: 2.6',
    'Operating System :: OS Independent',
    'Topic :: Software Development :: Libraries',
    'Topic :: Software Development :: Libraries :: Python Modules',
]

AUTHOR = 'Michael Foord & Nicola Larosa'

AUTHOR_EMAIL = 'fuzzyman@voidspace.org.uk'

KEYWORDS = "config, ini, dictionary, application, admin, sysadmin, configuration, validation".split(', ')


setup(name=NAME,
      version=VERSION,
      description=DESCRIPTION,
      long_description=LONG_DESCRIPTION,
      download_url=DOWNLOAD_URL,
      author=AUTHOR,
      author_email=AUTHOR_EMAIL,
      url=URL,
      py_modules=MODULES,
      classifiers=CLASSIFIERS,
      keywords=KEYWORDS
     )
