#!/usr/bin/env python
# -*- coding: utf-8 -*-

General
=======
see: http://www.python.org/dev/peps/pep-0008/
try: >>> import this


Code Layout
===========
Indentation
  * write max. 79 cols. just do it. reads better. can put two windows side-by
    side
  * limit flowing long blocks of text (docstrings or comments) to 72 chars
  * functions should not span more than 30-50 lines - just fill one window
  * separate classes: 2 blank lines
  * separate methods: 1 blank line
  * http://www.python.org/dev/peps/pep-0008/: 
    Code is much more read than it is written!


Blank Lines
  * top-level functions, classes: 2 lines
  * One blank line between functions.
  * Two blank lines between classes.
  * sparingly separate groups of methods by 1 extra line
  * Python accepts the control-L (i.e. ) which is page sep for many tools




Whitespace in Expressions and Statements
    Yes: spam(ham[1], {eggs: 2})
    No: spam( ham[ 1 ], { eggs: 2 } )

    Yes: if x == 4: print x, y; x, y = y, x
No: if x == 4 : print x , y ; x , y = y , x


Yes: spam(1)
No: spam (1)


use spaces around arithmetic operators

do not use whitespace around arguments
Yes: def complex(real, imag=0.0):
        return magic(r=real, i=imag)
No: def complex(real, imag = 0.0):
        return magic(r = real, i = imag)


Comments
========
  * write full sentencesstarting with capital (except from identifiers 
    beginning with lower case letter)
  * short comments: no .
  * block comments: allways .
  * indent # ... comments like the following code
  * separate pargraphs in block comments by lin containing single # 

Docstrings
==========
  * docstring becomes the __doc__ special attribute of that object
  * scripts/ standalone prog docstring 
        * this is the usage message, print when --help option is choosen
        * document function, cmd line options, env vars and files for script
        * may expand several pages and should be sufficient for a new user to
          use the command properly, as well as a complete quick reference to 
          all options and arguments for the sophisticated user
   * module docstring
        * list classes, exceptions and functions exported by module, one line
          summary of each
    * class docstring
        * behaviour, effect, public methods and instance variables
        * list subclassing interface(s) and overridden functions
        * class constructor should be documented in __init__ docstring
        * "override": subclass method replaces superclass method
        * "extend": subclass calls superclass method
    * method, function docstring
        * prescribe functions effect as command "do this, return that"
        * effect, behaviour, arguments, return values, side effects, 
          exceptions, restrictions when method/function can be called
        * indicate optional arguments
  * one - line """Doc string full sentence."""
  * multiliner
               """
               Summary line.

               line1
               line2
               """
  


Naming conventions
==================
    * _xxx  internal function, not imported via from module import *
    * __xx  method which shall not be found at class inheritation 
    * xxx_ avoid conflicts with internal keyword
    * variables:          lower_case, do not use l I O as single var names 
    * constants:          MAX_HIRE              # common
    * packages, modules:  lower_case            # Pep8
    * classes,exceptions: CapWords  (+ "Error") # Pep8
    * functions:          mixedCase             # separate them from variables

Some Names
==========
    Vererbung = Inheritation

    user  = usr
    group = grp
    other = otr
    owner = onr

    * method names (aka lvm)
    create
    change
    update
    remove
    rename
    read
    get
    set
    add
    rem






# function and classes print output
    * in general, do not print anything from within modules or class
      definitions. Errors are communicated via Exceptions.
    * all printing in modules can be done by log.debug( text ) after defining
      some logger and handler


# build strings in source code
# no! :
x = "line1" + \ # cannot use comments!
"line2"+ \
"line3"

# do:
x = (
"line1" # can use comments
"line2"
"line3"
)



"""
Douglas McIlroy, der Erfinder der Unix-Pipes, fasste die Philosophie folgendermaßen zusammen:

* Schreibe Computerprogramme so, dass sie nur eine Aufgabe erledigen und diese gut machen.
* Schreibe Programme so, dass sie zusammenarbeiten.
* Schreibe Programme so, dass sie Textströme verarbeiten, denn dies ist eine universelle Schnittstelle.

Gewöhnlich wird das verkürzt zu: „Mache nur eine Sache und mache sie gut.“

Von diesen drei Lehrsätzen sind vor allem die ersten beiden nicht auf Unix beschränkt, jedoch betonen Unix-Programmierer alle drei Lehrsätze stärker als andere Programmierer.
"""



"""
It should not be necessary to stress the importance scaling down; nevertheless, a lot of people are obsessed with features and concerned with the possibility of scaling up, forgetting the equally important issue of scaling down. This is an old meme in the computing world: programs should address the common cases simply and simple things should be kept simple, while at the same keeping difficult things possible. plac adhere as much as possible to this philosophy and it is designed to handle well the simple cases, while retaining the ability to handle complex cases by relying on the underlying power of argparse.
"""

"""
If you feel the need for speed, go for built-in functions - you can't beat a loop written in C. Check the library manual for a built-in function that does what you want. If there isn't one, here are some guidelines for loop optimization:

    Rule number one: only optimize when there is a proven speed bottleneck. Only optimize the innermost loop. (This rule is independent of Python, but it doesn't hurt repeating it, since it can save a lot of work. :-)
    Small is beautiful. Given Python's hefty charges for bytecode instructions and variable look-up, it rarely pays off to add extra tests to save a little bit of work.
    Use intrinsic operations. An implied loop in map() is faster than an explicit for loop; a while loop with an explicit loop counter is even slower.
    Avoid calling functions written in Python in your inner loop. This includes lambdas. In-lining the inner loop can save a lot of time.
    Local variables are faster than globals; if you use a global constant in a loop, copy it to a local variable before the loop. And in Python, function names (global or built-in) are also global constants!
    Try to use map(), filter() or reduce() to replace an explicit for loop, but only if you can use a built-in function: map with a built-in function beats for loop, but a for loop with in-line code beats map with a lambda function!
    Check your algorithms for quadratic behavior. But notice that a more complex algorithm only pays off for large N - for small N, the complexity doesn't pay off. In our case, 256 turned out to be small enough that the simpler version was still a tad faster. Your mileage may vary - this is worth investigating.
    And last but not least: collect data. Python's excellent profile module can quickly show the bottleneck in your code. if you're considering different versions of an algorithm, test it in a tight loop using the time.clock() function. 
"""

Funktionen sollten nur sich selber verändern und geschlossen über Parameter und Rückgabewerte mit dem umgebenden NameSpace kommunizieren
