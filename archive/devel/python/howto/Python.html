<html xmlns="http://www.w3.org/1999/xhtml"><head>
  <!-- Generator: Notebooks for Mac 1.1.2 -->
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
  <meta name="viewport" content="initial-scale=1.0, user-scalable=no">
  <title>New Note</title>
<!-- Notebooks Default Theme 1.3.2 -->
<style type="text/css">

body { 
	font-family: Source Sans Pro; 
	color: #000000; 
	font-size: 15px; 
	line-height: **NotebooksLinespacing**;
	background-color: #ffffff;
	background-image:url('**NotebooksBGImage**');
	padding: 5%;
	-webkit-hyphens: auto;
	margin: 0.0px 0.0px 0.0px 0.0px;
	-webkit-text-size-adjust: none;
}

p.head { 
	font-size: 1.4em; 
	line-height: 1.5em; 
	text-align: left; 
	font-weight: normal; 
	margin: 0em 0px 1.25em 0px; 
}

img { 
	width:auto; 
	max-width:70%; 
	height:auto; 
	-webkit-border-radius: 1px; 
	border: none; 
	padding: 12px !important; 
	background-color: #fff; 
	text-align: center; 
	overflow: hidden; 
	-webkit-box-shadow: 0 1px 3px #9e9c93; 
}

table { 
	border: 1px solid gray;  
	-webkit-border-radius: 3px; 
	padding: 6px !important; 
	-webkit-box-shadow: 0 1px 3px #9e9c93; 
	margin-left: auto; 
	margin-right: auto; 
}

table th { 
	padding-left: 30px; 
	padding-right: 30px; 
	vertical-align:top; 
}

table td { 
	padding-left: 30px; 
	padding-right: 30px;
	vertical-align:top; 
}

hr { 
	height: 1px; 
	margin: 2em 0em 4em 0;
	text-align: center; 
	background-color: #ddd;
	border-width: 0; 
}

h1 { 
	font-size: 1.4em; 
	text-align: left; 
	font-weight: normal; 
	line-height: 1.5em; 
	margin: 0em 0px 1.25em 0px; 
}

h2 { 
	font-size: 1.1em; 
	text-align: left; 
	font-weight: normal; 
	line-height: 1.5em; 
	letter-spacing: .1em; 
	margin: 2.5em 0 1em 0; 
	text-transform: uppercase; 
	border-bottom:1px solid #ddd;
}

h1 + h2 {
	margin-top: 1.5em;
}

h3 { 
	font-size: .91em; 
	text-align: left; 
	font-weight: normal; 
	line-height: 1.5em; 
	letter-spacing: .1em; 
	margin: 2.0em 0 1em 0; 
	text-transform: uppercase; 
}

h2 + h3 {
	margin-top: 2.5em;
}

h4, h5, h6 { 
	font-size: 1em; 
	text-align: left; 
	font-weight: bold; 
	line-height: 1.5em; 
	margin: 2em 0 0 0; 
}

blockquote { 
	font-size: 1em; 
	margin: 2em 2em 2em 1em; 
	padding: 0 .75em 0 1.25em; 
	border-left: 1px solid #777; 
}

blockquote strong { 
	font-weight: bold; 
	font-size: 1em; 
	letter-spacing: normal; 
	text-transform: none; 
}

ul, ol { 
	padding-left: 1.25em; 
	margin-left: 1em; 
	text-indent:0em;
}

li {
	padding-top: 0.25em;
	padding-bottom: 0.25em;
}

pre { 
	line-height: 1.45em; 
	background-color: inherit; 
	margin: 2em 0 2.5em 0; 
	padding: 5px 0 5px 10px; 
	border-width: 1px 0 1px 0; 
	border-color: #6b6b6b; 
	border-style: dashed; 
	width: auto;
	white-space: pre-wrap;
}

code { 
	font-size: 0.91em;
}

dt { 
	font-size: 1em; 
	text-align: left; 
	font-weight: normal; 
	margin-top: 0.5em; 
	letter-spacing: normal; 
	text-transform: none; 
}

dd { 
	margin: auto auto 0 2.25em; 
}


@media print  {

  body {
	background: white;
	padding: 0%;
  }

  h1 { 
	page-break-before: always;
  }

  h1:first-of-type {
    page-break-before: avoid;
    counter-reset: page;
  }

  h1, h2, h3, h4, h5, h6 {
	page-break-after:avoid; 
	page-break-inside:avoid 
  }

  blockquote, table, pre { 
	page-break-inside:avoid 
  }

  ul, ol, dl  { 
	page-break-before:avoid 
  }

  img { 
	page-break-inside:avoid; 
	page-break-after:avoid;
  }
}

</style>
</head>
<body>

<div class="errormsg systemmsg" id="sessionMsg">
	<div class="inner">
		<ul class="flashMsg">
			<li>Diese Seiten müssen noch komplett überarbeitet werden, Vorlage:&nbsp;<a href="mks://localhost/Abteilungen/Entwicklung/Executive/Tools/Windows/Powershell" title="Abteilungen/Entwicklung/Executive/Tools/Windows/Powershell">Powershell</a></li>
		</ul>
	</div>
</div>
<h2>Inhaltsverzeichnis</h2>
<p>{{ page.toc }}</p>
<h2>Einleitung</h2>
<p>Python eignet sich sehr gut, um komplexere Anwendungen zu erstellen</p>
<p style="margin-left: ;">Hilfreich für Bash Umsteiger: eine <a class="external" href="http://magazine.redhat.com/2008/02/07/python-for-bash-scripters-a-well-kept-secret/" title="http://magazine.redhat.com/2008/02/07/python-for-bash-scripters-a-well-kept-secret/">kleine Einführung</a>&nbsp;oder <a class="external" href="http://www.linuxjournal.com/content/python-scripts-replacement-bash-utility-scripts?page=0,2" title="http://www.linuxjournal.com/content/python-scripts-replacement-bash-utility-scripts?page=0,2">etwas tiefer</a>.</p>
<h2 style="margin-left: ;">Snippets</h2>
<p><span style="line-height: 1.5;">Simple Mysql connect on ubuntu systems:</span></p>
<pre>import MySQLdb
import configobj
CREDENTIAL_FILE = '/etc/mysql/debian.cnf'

class SqlConnect():
&nbsp;&nbsp;&nbsp; def __init__(self, ConfigFile):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.config = configobj.ConfigObj(ConfigFile)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.conn = MySQLdb.connect (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; host&nbsp;&nbsp; = self.config['client']['host'],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; user&nbsp;&nbsp; = self.config['client']['user'],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; passwd = self.config['client']['password'],
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use_unicode&nbsp;&nbsp;&nbsp; = True,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; charset&nbsp;&nbsp;&nbsp; ="utf8",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.conn.autocommit = True

&nbsp;&nbsp;&nbsp; def query(self, Query):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cursor = self.conn.cursor()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cursor.execute(Query)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fetch = cursor.fetchall()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cursor.close()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.conn.commit()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return fetch
# usage
sql = SqlConnect(CREDENTIAL_FILE)
print sql.query('SHOW DATABASES')

</pre>
<p style="margin-left: ;"><strong>Size of object in memory (e.g. big excel table)</strong></p>
<pre style="margin-left: ;">    sheet_size = sys.getsizeof(sheet) / 1024.0 / 1024
    log.debug( "Loaded excel worksheet, size is %.3f MB" % sheet_size )</pre>
<p style="margin-left: ;">&nbsp;</p>
<p style="margin-left: ;"><strong>Call system executable (bash), pipe in data and read output, raise on error</strong></p>
<pre style="margin-left: ;">process = subprocess.Popen(
&nbsp;&nbsp;&nbsp; [ MD5_EXE ],
&nbsp;&nbsp;&nbsp; stdin=subprocess.PIPE,
&nbsp;&nbsp;&nbsp; stdout=subprocess.PIPE,
&nbsp;&nbsp;&nbsp; stderr=subprocess.PIPE,
)
# pipe proxy host name to md5 execuable
stdout,stderr = process.communicate(input='%s\n' % Host['host'])
# TODO: error code auswerten
if not stderr == '':
&nbsp;&nbsp;&nbsp; raise Exception('Internal error calling md5sum:\n%s' % stderr)
print stdout</pre>
<p><strong>Simple shell command call with no output handling</strong></p>
<pre>import subprocess
subprocess.call("ls -l", shell=True)</pre>
<p style="margin-left: ;">Beispiel:</p>
<pre>IPADDR = """
/sbin/ifconfig -a | awk '/(cast)/ { print $2 }' | cut -d':' -f2 | head -1
"""
p = subprocess.Popen(IPADDR, shell=True, stdout=subprocess.PIPE)
out = p.stdout.read().strip()
return out&nbsp; #This is the stdout from the shell command</pre>
<p style="margin-left: ;"><strong>Verbosity setup</strong></p>
<pre style="margin-left: ;">parser = argparse.ArgumentParser()
parser.add_argument("-v", "--verbose", const=1, default=0, type=int, nargs="?",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; help="increase verbosity: 0 = only warnings, 1 = user info, 2 = debug and error tracing. No number means info. Default is no verbosity.")
args = parser.parse_args()

logger = logging.getLogger()
if args.verbose == 0:
&nbsp;&nbsp;&nbsp; logger.setLevel(logging.WARN)
elif args.verbose == 1:
&nbsp;&nbsp;&nbsp; logger.setLevel(logging.INFO)
elif args.verbose == 2:
&nbsp;&nbsp;&nbsp; logger.setLevel(logging.DEBUG)&nbsp;</pre>
<p style="margin-left: ;"><strong>Determine if Ipv4 IP is public or private</strong></p>
<pre style="margin-left: ;">import struct&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # for is_internal_ip
import socket&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # for is_internal_ip
def is_private_ip(ip):
&nbsp;&nbsp;&nbsp; """
&nbsp;&nbsp;&nbsp; see http://stackoverflow.com/questions/691045/how-do-you-determine-if-an-ip-address-is-private-in-python
&nbsp;&nbsp;&nbsp; using http://tools.ietf.org/html/rfc1918 and
&nbsp;&nbsp;&nbsp;&nbsp; http://tools.ietf.org/html/rfc3330. If you have 127.0.0.1 you just need
&nbsp;&nbsp;&nbsp;&nbsp; to &amp; it with the mask (lets say 255.0.0.0) and see if the value matches
&nbsp;&nbsp;&nbsp;&nbsp; any of the private network's network address. So using inet_pton you can
&nbsp;&nbsp;&nbsp;&nbsp; do: 127.0.0.1 &amp; 255.0.0.0 = 127.0.0.0
&nbsp;&nbsp;&nbsp; """
&nbsp;&nbsp;&nbsp; f = struct.unpack('!I',socket.inet_pton(socket.AF_INET,ip))[0]
&nbsp;&nbsp;&nbsp; private = (
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 2130706432, 4278190080 ], # 127.0.0.0,&nbsp;&nbsp; 255.0.0.0&nbsp;&nbsp; http://tools.ietf.org/html/rfc3330
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 3232235520, 4294901760 ], # 192.168.0.0, 255.255.0.0 http://tools.ietf.org/html/rfc1918
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 2886729728, 4293918720 ], # 172.16.0.0,&nbsp; 255.240.0.0 http://tools.ietf.org/html/rfc1918
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ 167772160 , 4278190080 ], # 10.0.0.0,&nbsp;&nbsp;&nbsp; 255.0.0.0&nbsp;&nbsp; http://tools.ietf.org/html/rfc1918
&nbsp;&nbsp;&nbsp; )
&nbsp;&nbsp;&nbsp; for net in private:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if (f &amp; net[1] == net[0]):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return True
&nbsp;&nbsp;&nbsp; return False</pre>
<h2>Date, Time</h2>
<p>Kalender-Datum in Epoch-Sekunden umrechnen</p>
<pre>&nbsp;</pre>
<pre>DATE = '2015-11-1'
Y, M, D = [ int(String) for String in DATE.split('-') ]
DateTime = datetime.datetime(Y, M, D, 0, 0)
EpochSeconds =&nbsp;calendar.timegm( DateTime.timetuple())
</pre>
<pre>&nbsp;</pre>

<pre>00 help.txt
=================================
# help with python in interpreter
help(): allgemeine Hilfe zu Python
help(obj): Hilfe zu einem Objekt, z.B. einer Funktion oder
 Modul
dir(): alle belegten Namen
dir(obj): alle Attribute eines Objekts

in shell: pydoc "module"

00-wiki.py
=================================

====== Python Scripting ======
===== Script Template =====
===== Style Guide and HowTo's =====

==== Script Structures, Error Handling ====



=== Exception Class ===

&nbsp; * allways inherit from Exception base class
&nbsp; * define Exception:&lt;code&gt;
class ShellError(Exception):
&nbsp;&nbsp;&nbsp; pass
class ShellSystemError(ShellError):
&nbsp;&nbsp;&nbsp; """Errors calling system commands"""
&nbsp;&nbsp;&nbsp; def __init__(self, cmd, msg, ecode):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.cmd&nbsp;&nbsp;&nbsp; = cmd
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.msg&nbsp;&nbsp;&nbsp; = msg
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.ecode&nbsp; = ecode
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ShellError.__init__(self, msg)
&lt;/code&gt;

&nbsp;&nbsp; * raise exception like:&lt;code&gt;
raise ShellSystemError(
&nbsp;&nbsp;&nbsp; err.cmd,
&nbsp;&nbsp;&nbsp; "Bad exit code %s for system command!" % err.returncode ,
&nbsp;&nbsp;&nbsp; err.returncode,
)
&lt;/code&gt;


&nbsp; * catch and usage exception like:&lt;code&gt;
try:
&nbsp;&nbsp;&nbsp; shell.system('ls -lt --badOPTION')
except ShellSystemError, err:
&nbsp;&nbsp;&nbsp; print err.ecode
&nbsp;&nbsp;&nbsp; print err.cmd
&lt;/code&gt;



==== Data Structures and Logic, Math ====
==== Text Files, Unicode, Strings and Regexp ====
=== Regular Expressions ===

&nbsp; * always use raw strings (r'' or r"") to contain patterns
&nbsp; * re.search() behaves like Perl's&nbsp; &lt;nowiki&gt;m//&lt;/nowiki&gt;, avoid using re.match()
&nbsp; * groups() method returns all matches as a tuple
&nbsp; * replace all instances of a pattern: re.sub(), limit to 1 ... 2nd match by "max" parameter
&nbsp; * make the regular expression match case-insensitive: add (?i) to the beginning of the expression
==== Filesystem, Date, Time ====
=== Handling Files and Folders ===
&nbsp; * open files and make sure this file is getting closed as soon as possible: &lt;code&gt;
with open("myfile.txt") as f:
&nbsp;&nbsp;&nbsp; for line in f:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print line,
&lt;/code&gt;
==== Config and Command Line Options ====
==== Logging, Mail and Messages ====
==== System Command Execution ====
==== Daemon, Threads, Parallel Processing ====
==== Databases, Net, RPC, Users, Groups ====



===== Fehlersuche, Debugging&nbsp; =====
00-wiki-snippets.py
=================================
====== Python Script Snippets ======

===== Script Structures, Error Handling =====
===== Data Structures and Logic, Math =====
===== Text Files, Unicode, Strings and Regexp =====
===== Filesystem, Date, Time =====
===== Config and Command Line Options =====
==== Config file comments ====

How to format comments, defaults and explanations for config file items
&lt;file&gt;
#
# Set config file format version.
#
ConfigFileVersion = "2.0"

#
# Enable or disable support for user profiles:
#
# 1: Enabled. The NX server allows the NX session to start
#&nbsp;&nbsp;&nbsp; according to the set of rules specified for the system
#&nbsp;&nbsp;&nbsp; or on a per-user basis.
#
# 0: Disabled. The NX server starts the session without apply-
#&nbsp;&nbsp;&nbsp; ing any rules.
#
# The administrator can configure access to applications and nodes
# by creating a specific profile for the NX system, which will be
# applied to any user starting a session on this server, or by def-
# ining profiles on a per-user basis. Any profile consists of a set
# of rules specifying what the user can or can't do in the session.
#
#EnableUserProfile = "0"
&lt;/file&gt;
===== Logging, Mail and Messages =====
===== System Command Execution =====
===== Daemon, Threads, Parallel Processing =====
===== Databases, Net, RPC, Users, Groups =====
10 logic, math.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

Comparison
&nbsp; Yes: if x is [not] None
&nbsp; No:&nbsp;&nbsp; if x&nbsp; == None
&nbsp; No:&nbsp;&nbsp; if x

do not compare bool to True/False
&nbsp; Yes: if seq:
&nbsp; Not: if seq == True

# conditions
# type a:
&nbsp;&nbsp;&nbsp; x = ( true_value if condition else false_value )

# type b:
&nbsp;&nbsp;&nbsp; if condition:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = true_value
&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; x = false_value




# variables simple
&gt;&gt;&gt; v = ('a', 'b', 'e')
&gt;&gt;&gt; (x, y, z) = v
&gt;&gt;&gt; x
'a'
&gt;&gt;&gt; y
'b'
&gt;&gt;&gt; z
'e'


# numbers
abs(x), round(x), x ** y, randint(a,b), random()


# bool
# in Python, and and or perform boolean logic as you would expect, but they do not return boolean values; instead, they return one of the actual values they are comparing.

False:
&nbsp;&nbsp;&nbsp; None, False, 0, '', [], (), {}, empty sets


# and-or-trick
&gt;&gt;&gt; a = "first"
&gt;&gt;&gt; b = "second"
&gt;&gt;&gt; 1 and a or b
'first'
&gt;&gt;&gt; 0 and a or b
'second'


# Using the and-or Trick Safely
The real trick behind the and-or trick, then, is to make sure that the value of a is never false. One common way of
doing this is to turn a into [a] and b into [b], then taking the first element of the returned list, which will be either a
or b.
&gt;&gt;&gt; a = ""
&gt;&gt;&gt; b = "second"
&gt;&gt;&gt; (1 and [a] or [b])[0]
''
# why do that? even if you need to use the more complicated safe form, there are good reasons to do so. For example, there are some cases in Python where if statements are not allowed, such as in lambda functions.


# check if variable is integer
&nbsp;&nbsp;&nbsp; def _isInt( self, var ):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; int_var = int(var)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; except ValueError:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return False
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return int_var


# comparison

def compare_ips(x, y):

&nbsp;&nbsp;&nbsp; # split and transfer ip segements to integer
&nbsp;&nbsp;&nbsp; x1, x2, x3, x4 = [ int(z) for z in x[0].split('.') ]
&nbsp;&nbsp;&nbsp; y1, y2, y3, y4 = [ int(z) for z in y[0].split('.') ]

&nbsp;&nbsp;&nbsp; # do comparison
&nbsp;&nbsp;&nbsp; if&nbsp;&nbsp; x1 &gt; y1: return&nbsp; 1
&nbsp;&nbsp;&nbsp; elif x1 &lt; y1: return -1
&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;&nbsp; x2 &gt; y2: return&nbsp; 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif x2 &lt; y2: return -1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;&nbsp; x3 &gt; y3: return&nbsp; 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif x3 &lt; y3: return -1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;&nbsp; x4 &gt; y4: return&nbsp; 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif x4 &lt; y4: return -1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0

def sortedIps( ips ):
&nbsp;&nbsp;&nbsp; return sorted( ips, cmp=compare_ips)


Comparison
&nbsp; Yes: if x is [not] None
&nbsp; No:&nbsp;&nbsp; if x&nbsp; == None
&nbsp; No:&nbsp;&nbsp; if x

do not compare bool to true/false
&nbsp; Yes: if seq:
&nbsp; Not: if seq == True

# anzahl ziffern (digits) in Zahl:

a = len(str(int))

12 strings.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

Strings:
&nbsp; * check for prefixes/ suffixes
&nbsp; use ''.startswith() and ''.endswith() instead of string slicing
&nbsp; * use r"""string""" to disable escape sequences like (echo -e)
&nbsp; * use u"""string""" for unicode strings

#UNICODE
# default Python 2 encoding is 'ascii'
# decode early, unicode everywhere, encode late
s.decode('utf-8') # read from disc or user input
&nbsp;&nbsp;&nbsp; * &lt;type 'str'&gt; to &lt;type 'unicode'&gt;
u.encode('utf-8') # when writing to disc or print
&nbsp;&nbsp;&nbsp; * &lt;type 'unicode'&gt; to &lt;type 'str'&gt;

# string formatting
integer, decimal %i, %d
hex:&nbsp;&nbsp; %x,%X
float %f,%F
float science %e,%E
char&nbsp; %c
string %s

str(None) # = string&nbsp; - None

if 'a' in name&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; : print 'Ja, er enthält den String "a".'
if name.find('war') != -1: print 'Ja, er enthält den String "war".'

import string
print string.rjust(`x`, 2)


s.count(sub [, start[, end]])&nbsp; # this is contains
s.upper(), s.lower()
s.replace(old, new[, count])
s.startswith(sub[, start[, end]]),
s.endswith(sub[, start[, end]])

# print single strings
 print "%s is not a good password for %s" % (pwd, uid)
&gt;&gt;&gt; print "Today's stock price: %f" % 50.4625
50.462500
&gt;&gt;&gt; print "Today's stock price: %.2f" % 50.4625
50.46
&gt;&gt;&gt; print "Change since yesterday: %+.2f" % 1.5

&gt;&gt;&gt; print "Today's stock price: %f" % 50.4625
50.462500
&gt;&gt;&gt; print "Today's stock price: %.2f" % 50.4625
50.46
&gt;&gt;&gt; print "Change since yesterday: %+.2f" % 1.5
+1.50


# user input
name = raw_input ( " Wie heisst du ? " )
print " Hallo " , name

# build strings in source code
# no! :
x = "line1" + \ # cannot use comments!
"line2"+ \
"line3"

# do:
x = (
"line1" # can use comments
"line2"
"line3"
)


13 regexp.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# regular expressions
# If what you're trying to do can be accomplished with string functions, you should use them. They're fast and simple and easy to read, and there's a lot to be said for fast, simple, readable code. Some people, when confronted with a problem, think "I know, I'll use regular expressions." Now they have two problems.

# find all lines starting with numbers
sizeRe = re.compile(r"^(\d+)(.*)$")

for line in sys.stdin.readlines():
&nbsp;&nbsp;&nbsp; mo = sizeRe.match(line)
&nbsp;&nbsp;&nbsp; if mo:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; size = int(mo.group(1))


 = '100 NORTH MAIN ROAD'
&gt;&gt;&gt; s.replace('ROAD', 'RD.')
'100 NORTH MAIN RD.'
&gt;&gt;&gt; s = '100 NORTH BROAD ROAD'
&gt;&gt;&gt; s.replace('ROAD', 'RD.')
'100 NORTH BRD. RD.'
&gt;&gt;&gt; s[:-4] + s[-4:].replace('ROAD', 'RD.')
'100 NORTH BROAD RD.'
&gt;&gt;&gt; import re
&gt;&gt;&gt; re.sub('ROAD$', 'RD.', s)
'100 NORTH BROAD RD.'


re.sub(r'\bROAD\b', 'RD.', s) # r'\' is the raw string \, always use raw strings
re.search(pattern, string [,re.VERBOSE])
re.compile




\b...\b # word anywhere in string
\d means "any numeric digit"
\D matches any non-numeric character.
x? matches an optional x character (in other words, it matches an x zero or one times).
x* matches x zero or more times.
x+ matches x one or more times.
x{n,m} matches an x character at least n times, but not more than m times.
(a|b|c) matches either a or b or c.
(x) in general is a remembered group. You can get the value of what matched by using the groups()
method of the object returned by re.search.




# verbose regular expressions
# whitespace and comments ignored
&gt;&gt;&gt; pattern = '''
&nbsp;&nbsp;&nbsp; ^&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # beginning of string
&nbsp;&nbsp;&nbsp; M{0,4}&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # thousands - 0 to 4 M's
&nbsp;&nbsp;&nbsp; (CM|CD|D?C{0,3}) # hundreds - 900 (CM), 400 (CD), 0-300 (0 to 3 C's),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or 500-800 (D, followed by 0 to 3 C's)
&nbsp;&nbsp;&nbsp; (XC|XL|L?X{0,3}) # tens - 90 (XC), 40 (XL), 0-30 (0 to 3 X's),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or 50-80 (L, followed by 0 to 3 X's)
&nbsp;&nbsp;&nbsp; (IX|IV|V?I{0,3}) # ones - 9 (IX), 4 (IV), 0-3 (0 to 3 I's),
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; or 5-8 (V, followed by 0 to 3 I's)
&nbsp;&nbsp;&nbsp; $&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # end of string
&nbsp;&nbsp;&nbsp; '''
&gt;&gt;&gt; re.search(pattern, 'M', re.VERBOSE)&nbsp; # important: re.VERBOSE


&gt;&gt;&gt; phonePattern = re.compile(r'''
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # don't match beginning of string, number can start anywhere
&nbsp;&nbsp;&nbsp; (\d{3})&nbsp;&nbsp;&nbsp;&nbsp; # area code is 3 digits (e.g. '800')
&nbsp;&nbsp;&nbsp; \D*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # optional separator is any number of non-digits
&nbsp;&nbsp;&nbsp; (\d{3})&nbsp;&nbsp;&nbsp;&nbsp; # trunk is 3 digits (e.g. '555')
&nbsp;&nbsp;&nbsp; \D*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # optional separator
&nbsp;&nbsp;&nbsp; (\d{4})&nbsp;&nbsp;&nbsp;&nbsp; # rest of number is 4 digits (e.g. '1212')
&nbsp;&nbsp;&nbsp; \D*&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # optional separator
&nbsp;&nbsp;&nbsp; (\d*)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # extension is optional and can be any number of digits
&nbsp;&nbsp;&nbsp; $&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # end of string
&nbsp;&nbsp;&nbsp; ''', re.VERBOSE)
&gt;&gt;&gt; phonePattern.search('work 1-(800) 555.1212 #1234').groups()
('800', '555', '1212', '1234')
&gt;&gt;&gt; phonePattern.search('800-555-1212')
('800', '555', '1212', '')
14 lists, tupels, sets, dicts.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-


Lists:
&nbsp; * check if empty
&nbsp; Yes: if not seq:
&nbsp; No:&nbsp; if len(seq):


# ranges
range(7)
[0, 1, 2, 3, 4, 5, 6]
(MONDAY, TUESDAY, WEDNESDAY, THURSDAY, FRIDAY, SATURDAY, SUNDAY) = range(7)
MONDAY is 0, now



# dictionary
dictionary = perl hash = assoziative array

d = {"server":"mpilgrim", "database":"master"}
print d['server']


del&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # remove key ( + value)
d.clear()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # remove all keys
d.copy()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # create copy
if key in d:&nbsp;&nbsp;&nbsp; # contains
d.items()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # list of (key, value)
d.keys()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # list of keys
d.values()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # list of values
d.get(key1, key2)&nbsp;&nbsp; # get some values
d.pop(key1, key2)&nbsp;&nbsp; # get + remove some values


# lists = arrays
a.append(x)&nbsp; # append single element to list
a.extend(s2) # s + s2
a.pop(i)&nbsp;&nbsp;&nbsp;&nbsp; # return and remove element at position i
a.index("example") # find "example" in&nbsp; array
a.remove(element)
a.reverse() # reverse whole list
x in a, x not in a&nbsp; # list contains element?
min(a), max(a)
element i in a: a[i], from end: a[-i]
subsequence in a: a[i:j]


# take care:
a2 = a1 # makes changes to a2 happen in a1, too (reference!)
# to avoid, make a flat copy
a2 = a1[:] # or
a2 = list(a1)

&gt;&gt;&gt; a = ["a", "b", "mpilgrim", "z", "example"]
&gt;&gt;&gt; a[-2]
z
&gt;&gt;&gt; a[1:-2]
a b mpilgrim z

# print lists
&gt;&gt;&gt; li = ['a', 'b', 'c']
&gt;&gt;&gt; "\n".join(li)
a
b
c

&gt;&gt;&gt; li = [1, 2] * 3

# array mapping
&gt;&gt;&gt; li = [1, 9, 8, 4]
&gt;&gt;&gt; li = [elem*2 for elem in li if elem &gt; 1]
&gt;&gt;&gt; li
[ 18, 16, 8]


# sort by nth element of list
# Suppose, for example, you have a list of tuples that you want to sort by the n-th field of each tuple. The following function will do that.

def sortby(somelist, n):
&nbsp;&nbsp;&nbsp; nlist = [(x[n], x) for x in somelist]
&nbsp;&nbsp;&nbsp; nlist.sort()
&nbsp;&nbsp;&nbsp; return [val for (key, val) in nlist]



# It is not possible to sort a dict, only to get a representation of a dict that is sorted. Dicts are inherently orderless, but other types, such as lists and tuples, are not. So you need a sorted representation, which will be a list—probably a list of tuple

import operator
x = {1: 2, 3: 4, 4:3, 2:1, 0:0}
sorted_x = sorted(x.iteritems(), key=operator.itemgetter(1))



Lists:
&nbsp; * check if empty
&nbsp;&nbsp;&nbsp; Yes: if not seq:
&nbsp;&nbsp;&nbsp; No:&nbsp; if len(seq):


# unify lists
# note you can use these on pure lists only, lists of hashes do not work
def uniq(alist)&nbsp;&nbsp;&nbsp; # Fastest, does order preserving
&nbsp;&nbsp;&nbsp; set = {}
&nbsp;&nbsp;&nbsp; return [set.setdefault(e,e) for e in alist if e not in set]

def uniq(alist)&nbsp;&nbsp;&nbsp; # Fastest without order preserving
set = {}
map(set.__setitem__, alist, [])
return set.keys()





# tupels
tStuff=()

Tuples
&nbsp;&nbsp;&nbsp; * are faster than lists
&nbsp;&nbsp;&nbsp; * have no methods
&nbsp;&nbsp;&nbsp; * are write - protected
&nbsp;&nbsp;&nbsp; * can be keys in dictionaries


# sets&nbsp; (Mengen)
s = set([sequence]) # make s contain unordered, unified members of sequence
t = set([sequence2])
# tests
from sets import Set
&nbsp;&nbsp;&nbsp; Set(s).issubset(t)&nbsp;&nbsp; # does t contain all members of s?
&nbsp;&nbsp;&nbsp; Set(s).issuperset(t) # does s contain all members of t?

list( Set(s).union(t) )&nbsp; # s + t, unified, returns set, s and t can be lists
Set(s).intersection(t)&nbsp;&nbsp; # members which reside in bot s and t
Set(s).difference(t)&nbsp;&nbsp;&nbsp;&nbsp; # members of s not in t, members of t not in s
Set(s).symmetric_difference(t) # elements that are in exactly one of the sets

# turn set to list again
sl = list(s)

# convert text to array with stripped contents:

classifiers = filter(None, map(str.strip, """
&nbsp;&nbsp;&nbsp; Development Status :: 4 - Beta
&nbsp;&nbsp;&nbsp; Topic :: Utilities
&nbsp;&nbsp;&nbsp; Environment :: Console
""".split('\n')))

['Development Status :: 4 - Beta', 'Topic :: Utilities', 'Environment :: Console']
20 loops, generators.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# see itertools:
http://docs.python.org/library/itertools.html


# for loop: else
for i in range (0 , 10 , 2):
&nbsp;&nbsp; print i&nbsp;&nbsp;&nbsp; # 0 , 2 , 4 , ... , 8
else :
&nbsp;&nbsp; print " Schleife komplett durchlaufen . "


#If you need both the index and the item, use the enumerate function:

&nbsp;&nbsp;&nbsp; for index, item in enumerate(L):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print index, item

#If you need only the index, use range and len:

&nbsp;&nbsp;&nbsp; for index in range(len(L)):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print index

#The list object supports the iterator protocol. To explicitly create an iterator, use the built-in iter function:

&nbsp;&nbsp;&nbsp; i = iter(L)
&nbsp;&nbsp;&nbsp; item = i.next() # fetch first value
&nbsp;&nbsp;&nbsp; item = i.next() # fetch second value


# switch
&gt;&gt;&gt;def a(s):
&gt;&gt;&gt; print s
&gt;&gt;&gt;def switch(ch):
&gt;&gt;&gt; try:
&gt;&gt;&gt; {'1': lambda : a("one"),
&gt;&gt;&gt; '2': lambda : a("two"),
&gt;&gt;&gt; '3': lambda : a("three"),
&gt;&gt;&gt; 'a': lambda : a("Letter a")
&gt;&gt;&gt; }[ch]()
&gt;&gt;&gt; except KeyError:
&gt;&gt;&gt; a("Key not Found")
&gt;&gt;&gt;switch('1')
one
&gt;&gt;&gt;switch('a')
Letter a
&gt;&gt;&gt;switch('b')
Key not Found


# speed up "for loops"
example:
newlist = []
for word in oldlist:
&nbsp;&nbsp;&nbsp; newlist.append(word.upper())

# fastest: (push from interpreter to C code)
newlist = map(str.upper, oldlist)

# safe memory: avoid the overhead of generating the entire list at once
newlist = (s.upper() for s in oldlist)

# if you need to have a for loop, speed up by * avoiding dot references * using local vars (much faster)
def iupperList( oldlist):
&nbsp;&nbsp;&nbsp; upper = str.upper
&nbsp;&nbsp;&nbsp; append = newlist.append
&nbsp;&nbsp;&nbsp; for word in oldlist:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield(upper(word))

# iterator with condition
a = [ i**2 for i in range(10) if i != 4]


# iterators, generators

#Suppose we want a stream of positive random numbers less than one that obey a backward-looking constraint. Specifically, we want each successive number to be at least 0.4 more or less than the last one. Moreover, the stream itself is not infinite, but rather ends after a random number of steps. For the examples, we will simply end the stream when a number less than 0.1 is produced

# a) use a "static" function-local variable to remember things about the last invocation of a function
import random
def randomwalk_static(last=[1]):&nbsp;&nbsp;&nbsp; # init the "static" var(s)
&nbsp;&nbsp;&nbsp; rand = random.random()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # init a candidate value
&nbsp;&nbsp;&nbsp; if last[0] &lt; 0.1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # threshhold terminator
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return None&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # end-of-stream flag
&nbsp;&nbsp;&nbsp; while abs(last[0]-rand) &lt; 0.4:&nbsp; # look for usable candidate
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print '*',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # display the rejection
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rand = random.random()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # new candidate
&nbsp;&nbsp;&nbsp; last[0] = rand&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # update the "static" var
&nbsp;&nbsp;&nbsp; return rand
# call like
num = randomwalk_static()
while num is not None:
&nbsp;&nbsp;&nbsp; print num,
&nbsp;&nbsp;&nbsp; num = randomwalk_static()

# b) use iterator
import random
class randomwalk_iter:
&nbsp;&nbsp;&nbsp; def __init__(self):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.last = 1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # init the prior value
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.rand = random.random() # init a candidate value
&nbsp;&nbsp;&nbsp; def __iter__(self):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # simplest iterator creation
&nbsp;&nbsp;&nbsp; def next(self):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if self.rand &lt; 0.1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # threshhold terminator
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise StopIteration&nbsp;&nbsp;&nbsp;&nbsp; # end of iteration
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # look for usable candidate
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while abs(self.last-self.rand) &lt; 0.4:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print '*',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # display the rejection
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.rand = random.random() # new candidate
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.last = self.rand&nbsp;&nbsp; # update prior value
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return self.rand

# call like
for num in randomwalk_iter():
&nbsp;&nbsp;&nbsp; print num,

# c) use generator
import random
def randomwalk_generator():
&nbsp;&nbsp;&nbsp; last, rand = 1, random.random() # initialize candidate elements
&nbsp;&nbsp;&nbsp; while rand &gt; 0.1:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # threshhold terminator
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print '*',&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # display the rejection
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if abs(last-rand) &gt;= 0.4:&nbsp;&nbsp; # accept the number
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; last = rand&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # update prior value
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield rand&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # return AT THIS POINT
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; rand = random.random()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # new candidate
&nbsp;&nbsp;&nbsp; yield rand&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # return the final small element

# call like
for num in randomwalk_generator():
&nbsp;&nbsp;&nbsp; print(num)
# or
gen = randomwalk_generator()
try:
&nbsp;&nbsp;&nbsp; while 1: print gen.next(),
except StopIteration:
&nbsp;&nbsp;&nbsp; pass



# iterator /generator within recursion

# call recursion
def listChilds( parent_pid = None):
&nbsp;&nbsp;&nbsp; ppid = validate.is_integer( parent_pid )
&nbsp;&nbsp;&nbsp; for pid in recurse( ppid ):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print pid

# loop control
def recurse( ppid ):
&nbsp;&nbsp;&nbsp; yield ppid
&nbsp;&nbsp;&nbsp; pids = yieldChilds( ppid )
&nbsp;&nbsp;&nbsp; for pid in pids:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for pid in recurse( pid):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield pid

# atom operation
def yieldChilds( pid ):
&nbsp;&nbsp;&nbsp; cmd = "ps --no-headers --ppid %d -o pid" % pid
&nbsp;&nbsp;&nbsp; stdout = subprocess.Popen(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; cmd.split(), stdout=subprocess.PIPE
&nbsp;&nbsp;&nbsp; ).stdout
&nbsp;&nbsp;&nbsp; for line in stdout:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; yield( validate.is_integer( line ) )

30 modules, import.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-



# module file and&nbsp; call structures YES:
&nbsp;&nbsp;&nbsp; # simple case: one class in one module dir
&nbsp;&nbsp;&nbsp; module/
&nbsp;&nbsp;&nbsp; +-- __init__.py
&nbsp;&nbsp;&nbsp; +-- module.py

&nbsp;&nbsp;&nbsp; * __init__.py
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from module import *

&nbsp;&nbsp;&nbsp; * module.py
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __all__=['Class, Error']
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class Error(BaseException)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class Class

&nbsp;&nbsp;&nbsp; * call like
&nbsp;&nbsp;&nbsp; import module
&nbsp;&nbsp;&nbsp; try:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; a=module.Class
&nbsp;&nbsp;&nbsp; except module.Error, emsg:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...


&nbsp;&nbsp;&nbsp; # mutiple classes in one module dir
&nbsp;&nbsp;&nbsp; module/
&nbsp;&nbsp;&nbsp; +-- __init__.py
&nbsp;&nbsp;&nbsp; +-- A.py
&nbsp;&nbsp;&nbsp; +-- B.py

&nbsp;&nbsp;&nbsp; * __init__.py
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from A import *
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from B import *

&nbsp;&nbsp;&nbsp; * A.py
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __all__=['ClassA, Error']
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class Error(BaseException)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class ClassA

&nbsp;&nbsp;&nbsp; * B.py
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; __all__=['ClassB, Error']
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class Error(BaseException)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; class ClassB

&nbsp;&nbsp;&nbsp; * call like
&nbsp;&nbsp;&nbsp; import module.A
&nbsp;&nbsp;&nbsp; try:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; b=module.A.ClassA
&nbsp;&nbsp;&nbsp; except module.A.Error, emsg:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ...





# call method by name in variable
&nbsp;&nbsp;&nbsp; def handle_cmd(self, cmd=None):

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; method_ref=getattr(self,cmd)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; method_ref()




# modules
# program doesn't run any faster when it is read from a .pyc or .pyo file than when it is read from a .py file; the only thing that's faster about .pyc or .pyo files is the speed with which they are loaded.
if __name__ == '__main__':
&nbsp;&nbsp;&nbsp; print 'Dieses Programm laeuft selbst'
else:
&nbsp;&nbsp;&nbsp; print 'Ich werde von einem anderen Modul importiert'


# remove actual dir from search path
&nbsp;&nbsp;&nbsp; sys.path.pop(0)



# module import syntax
from math import pi as PI , sin
from math import *

# module search path
sys.path()

# modules
top level commands are beeing executed at module import



# module import in inline code:
&nbsp;&nbsp;&nbsp; avoid multiple calls to import (slows down execution),
&nbsp;&nbsp;&nbsp; set some if - clause or try-exception to import only ones

## Build a compressed self-extracting executable script on UNIX

#This shows how to build a compressed self-extracting script. This is a handy way to package a group of python modules into a single compressed self-extracting executable script. This works on UNIX and Cygwin with Python 2.3 Final or later.


#!/bin/sh
# This is a self-extracting executable.
# Execute this like any normal executable.
# You may need to "chmod a+x" this file.
# This is a binary ZIP file with a Python loader header.
#
# Bourne shell loader:
PYTHON=$(which python 2&gt;/dev/null)
if [ ! -x "$PYTHON" ] ; then
&nbsp;&nbsp;&nbsp; echo "Python not found!"
&nbsp;&nbsp;&nbsp; exit 1
fi
exec $PYTHON -c "
# Python loader:
import sys, os
if int(sys.version[0])&lt;2:
&nbsp;&nbsp;&nbsp; print 'Python version 2.3 final or greater is required.'
&nbsp;&nbsp;&nbsp; print 'Your version is', sys.version
&nbsp;&nbsp;&nbsp; os._exit(1)
major = sys.version_info[0]
minor = sys.version_info[1]
releaselevel = sys.version_info[3]
if (major==2 and minor&lt;3) or (major==2 and minor==3 and releaselevel!='final'):
&nbsp;&nbsp;&nbsp; print 'Python version 2.3 final or greater is required.'
&nbsp;&nbsp;&nbsp; print 'Your version is', sys.version
&nbsp;&nbsp;&nbsp; os._exit(1)
sys.path.insert(0, sys.argv[1])
del sys.argv[0:1]
import MY_SCRIPT
MY_SCRIPT.main()
" $0 $@
# Zip file:


# Assume the following situation:
* you have a script called MY_SCRIPT.py with a main() function.
* your script imports a number of other modules in the local directory.
* you want to distribute this script to others as a single executable script that does not require installation or unpacking of all the other modules.

# Step 1. Compress your project into a ZIP file:

 zip MY_SCRIPT.ZIP *.py

# Step 2. Add the shell script header source to the ZIP file. Be sure to change the two references to MY_SCRIPT to the actual name of your script:

&nbsp; cat zip_header.sh MY_SCRIPT.ZIP &gt; SCRIPT

# Step 3. Make the SCRIPT executable.

&nbsp;&nbsp; chmod 775 SCRIPT

# Step 4. Now run your self-extracting executable ./SCRIPT
# This does not corrupt the ZIP file and it is a valid shell script even though it is binary. This is a wrapper, within a wrapper, within a wrapper, but it actually works and it isn't too complicated to build for most projects.
# Python is able to run code inside of a ZIP file. The shell script header starts python which runs another pythin script header that loads and run the main function in your script.


32 error handling.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

try except:
&nbsp; keep try- code as short as possible (avoids masking bugs)

#print original python backtrace
class SubClassError()
&nbsp;&nbsp;&nbsp; """Error running (user-defined) subclass method"""

def test():
&nbsp;&nbsp;&nbsp; a = 3/0

def holla():
&nbsp;&nbsp;&nbsp; try:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; test()
&nbsp;&nbsp;&nbsp; except BaseException, emsg:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; import traceback
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise SubclassError((
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 'Error running test, message "%s"\n&nbsp; &gt; %s'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; % (emsg ,'\n&nbsp; &gt; '.join(traceback.format_exc(3).splitlines()))
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )

holla()




# exception handling
"""
Accessing a non-existent dictionary key will raise a KeyError exception.
Searching a list for a non-existent value will raise a ValueError exception.
Calling a non-existent method will raise an AttributeError exception.
Referencing a non-existent variable will raise a NameError exception.
Mixing datatypes without coercion will raise a TypeError exception.
Importing a module that does not exist will raise an ImportError exception.
"""


# example
# wrapper module for getting a password from the user. Getting a password is accomplished differently on UNIX, Windows, and Mac OS platforms, but this code encapsulates all of those differences.


# Bind the name getpass to the appropriate function
try:
&nbsp;&nbsp;&nbsp;&nbsp; import termios, TERMIOS
except ImportError:
&nbsp;&nbsp;&nbsp;&nbsp; try:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; import msvcrt
&nbsp;&nbsp;&nbsp;&nbsp; except ImportError:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from EasyDialogs import AskPassword
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; except ImportError:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getpass = default_getpass
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getpass = AskPassword
&nbsp;&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getpass = win_getpass
else:

getpass = unix_getpass


# each time you want to catch IOError OR
# OSError together, just catch EnvironmentError, their common
# baseclass!&nbsp; It's rare (though not unheard of) to want to catch
# them separately and distinctly.

# I don't
# think I've ever caught anything broader than StandardError not Bare Exceptions


#Use EAFP instead of LBYL:
#========================
#&nbsp;&nbsp;&nbsp; try:
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; useappropriately(thefile)
#&nbsp;&nbsp;&nbsp; except ItWasWrong, howwasitwrong:
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; dealwithwrongness()

# You don't have to code a separate 'iswhatiwant' test -- what you DO want is
# determined inherently by what 'useappropriately' tries to do.&nbsp; No race
# conditions, no code that must duplicate the set of conditions to be checked
# for, no duplicate work at runtime in terms of system calls to determine if
# a condition holds followed by system calls


# program a single "do this" operation, which will either fail, or atomically
# succeed-and-perform

"""
Locking
=======
&gt; If race conditions are a problem shouldn't we be doing something like
&gt;
&gt; while not havelockon(thefile):
&gt;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; pass&nbsp;&nbsp;&nbsp; # or sleep etc
&gt; useappropriately(thefile)
&gt; giveuplockon(thefile)
&gt;
&gt; if we actually need to do something with/to thefile?

I don't know, should we?&nbsp; Will that lock lock all of the directories
upwards from the file, all the way up to root, so that no permission
change can occur that may invalidate whatever tests you're performing
in the LBYL version -- just for example?&nbsp; I've never seen any lock
mechanism or convention that was as powerful as that -- and yet it
would seem to be a very fundamental operation.

On the other hand, simply trying to open the file for reading will
either succeed or fail and (at least in the implementations I'm
familiar with) if it succeeds it leaves you with a handle suitable
for reading no matter what changes occur later on directories &amp;c.
"""


# hand over error messages through an error chain:

&nbsp;&nbsp;&nbsp; raise ExampleError3( message3 )
&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp; except ExampleError3, emsg:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise ExampleError2(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "message2"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "\n%s" % emsg
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
&nbsp;&nbsp;&nbsp; ...
&nbsp;&nbsp;&nbsp; except ExampleError2, emsg:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise ExampleError( "message\n%s" % emsg )

&nbsp;&nbsp;&nbsp; except ExampleError, emsg:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print emsg
&nbsp;&nbsp;&nbsp; =&gt;
&nbsp;&nbsp;&nbsp; message
&nbsp;&nbsp;&nbsp; message2
&nbsp;&nbsp;&nbsp; message3






34 threads.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-



# threads
class Counter ( threading.Thread ):
&nbsp;&nbsp;&nbsp; def __init__ ( self ):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; threading.Thread.__init__( self )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.counter = 0
&nbsp;&nbsp;&nbsp; def run ( self ): # Hauptteil
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while self.counter &lt; 10:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.counter += 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print self.counter
counter = Counter()
counter.start() # Thread starten
# hier etwas gleichzeitig tun ...
counter.join() # Warte auf Ende des Threads


# locking
# Problem, wenn zwei Threads gleichzeitig auf das gleiche Objekt schreibend zugreifen wollen!
# Verhindern, dass Programmteile gleichzeitig ausgefuehrt werden

l = threading.Lock()
l.aquire() # Warte bis Lock frei ist und locke es dann
... some code
l.release() # Lock freigeben fuer andere

# events - communication between threads
# example: tell threads to stop executing
e.isSet() # check event state
e.set()&nbsp;&nbsp; # set event
e.clear() # reset event
e.wait([timeout]) # wait for event


40 files, unicode, time.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

#UNICODE
# default Python 2 encoding is 'ascii'
# decode early, unicode everywhere, encode late
s.decode('utf-8') # read from disc or user input
&nbsp;&nbsp;&nbsp; * &lt;type 'str'&gt; to &lt;type 'unicode'&gt;
u.encode('utf-8') # when writing to disc or print
&nbsp;&nbsp;&nbsp; * &lt;type 'unicode'&gt; to &lt;type 'str'&gt;


# replace everything not a-z0-9 by '_' after converting ÄÖÜäöüß

def renice( name = None ):
&nbsp;&nbsp;&nbsp; name1 = re.sub( '\\xf6', 'oe',&nbsp; name.lower()&nbsp; )
&nbsp;&nbsp;&nbsp; name2 = re.sub( '\\xe4', 'ae',&nbsp; name1&nbsp; )
&nbsp;&nbsp;&nbsp; name3 = re.sub( '\\xfc', 'ue',&nbsp; name2&nbsp; )
&nbsp;&nbsp;&nbsp; name4 = re.sub( '\\xdf', 'ss',&nbsp; name3&nbsp; )
&nbsp;&nbsp;&nbsp; return&nbsp; re.sub( '[^a-z0-9]', '_',&nbsp; name4&nbsp; )


# UnicodeEncodeError bei print Ausgabe: Python nimmt für stdout standardmäßig ascii an, läßt sich mit
print sys.stdout.encoding

# anzeigen. sys.stdout.encoding ist ro aber läßt sich folgendermaßen setzen
sys.stdout = codecs.getwriter('UTF-8')(sys.stdout)



# file operation
datei2 = open ( " / tmp / eggs " , " wb " )
r, w, b=binary, a=append, r+=rw
f.read&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # read whole file
f.readline&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # read one line
f.write(string)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # write to file
f.writelines(sequence)&nbsp; # write array/tupel to file, terminate lines by '\n'
f.close&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # close file

# read file line by line (using generator for eventually huge files)
&nbsp;&nbsp;&nbsp; proc_mounts_fh = open( MOUNT_LIST, 'r')
&nbsp;&nbsp;&nbsp; for line in proc_mounts_fh.xreadlines():
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print line,
&nbsp;&nbsp;&nbsp; proc_mounts_fh.close()


# touch a file
&nbsp;&nbsp;&nbsp; # set time of existing file:
&nbsp;&nbsp;&nbsp; os.utime( path, None)

&nbsp;&nbsp;&nbsp; # create not existing file
&nbsp;&nbsp;&nbsp; open(path, 'w').close()


# make sure line exists in file
&nbsp;&nbsp;&nbsp; # make sure nobody is in sudoers file
&nbsp;&nbsp;&nbsp; sudoers_line = """nobody ALL = NOPASSWD: /bin/ip route *"""
&nbsp;&nbsp;&nbsp; for line in open( SUDOERS_FILE, 'r' ).readlines():
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if line.find( sudoers_line ) &gt; -1:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break
&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fh_sudoers = open( SUDOERS_FILE, 'a' )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fh_sudoers.write( sudoers_line + "\n" )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; fh_sudoers.close()




# os.path
path = os.path.normpath(self.path)
&nbsp;&nbsp;&nbsp; if os.path.isabs(path):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; path = path[1:]&nbsp;&nbsp;&nbsp; # safe assumption due to normpath above


realpath(path)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # resolve symlinks
join(path1 path2)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # concentate proper path
splitext(path)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # get path extension
isfile(path)
isdir(path)
islink(path)
getcdw()&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # get current work dir
chmod(path, mode)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # mode = 0744 or
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # stat.S_IRUSR

chown(path, uid, gid)&nbsp;&nbsp; # numerical uid, gid!
makedirs(path, [mode]
remove(path)
removedirs(path)
rmtree&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # recursively
rename(src, dst)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # rename
move(src,dst)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # move recursively

listdir(path)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # all files in dir
glob.iglob('/tmp/*.tmp')&nbsp;&nbsp;&nbsp;&nbsp; # generator for walking entries by shell glob
copy(src,dst)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # for files and dirs
copytree(src,dst[, symlinks])&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # recursively

# split a path into dir and filename from full_path
(dirpath, filename) = os.path.split(full_path)
# get all members of path
path_parts = full_path.split( os.sep )



# test if file is accessible (may not work with acls on network file systems)
&nbsp;&nbsp;&nbsp; if os.access("some-filename", os.W_OK)
&nbsp;&nbsp;&nbsp; if os.access("some-filename", os.R_OK)
&nbsp;&nbsp;&nbsp; if os.access("some-filename", os.X_OK)

# create pathes (mkpath)
&nbsp;&nbsp;&nbsp; os.makedirs ( sPath )



# siehe rdiff.scheduler()

# simple pipe handler, read 256 bytes at once

#! /usr/local/bin/python
import sys
while 1:
&nbsp;&nbsp;&nbsp; data = sys.stdin.read(256)
&nbsp;&nbsp;&nbsp; if data != '':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # do some processing of the contents of
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # the data variable
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; data = '#'+data
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # end of data processing command group
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sys.stdout.write(data)
&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sys.stdout.flush()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break

for line in sys.stdin.readlines():
&nbsp;&nbsp;&nbsp; print line


# signal handling, temp/lock file
# signal handling, temp/lock file
#! /usr/local/bin/python
import os
import tempfile
import sys
import signal
t_path = ''
t_file = None
def cleanup(signal, frame):
&nbsp;&nbsp;&nbsp; if t_path != '' and t_file != None:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print 'Cleaning up temporary files ...'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; os.close(t_file)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; os.remove(t_path)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print 'Done!'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sys.exit(0)
&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sys.exit(0)
signal.signal(signal.SIGHUP, cleanup)
signal.signal(signal.SIGINT, cleanup)
signal.signal(signal.SIGQUIT, cleanup)
signal.signal(signal.SIGTERM, cleanup)
try:
&nbsp;&nbsp;&nbsp; t_path = tempfile.mktemp()
&nbsp;&nbsp;&nbsp; t_file = os.open(t_path, os.O_CREAT | os.O_RDWR)
except IOError:
&nbsp;&nbsp;&nbsp; print 'Error:&nbsp; Couldn\'t create temp file.'
&nbsp;&nbsp;&nbsp; sys.exit(0)
#
# always close and remove the temp file
# before you exit from script
cleanup(t_path, t_file)




# compress and decompress data to file
import bz2
f=open("test.txt", "w")
f.write(bz2.compress("mypassword"))
f.close()
w = open("test.txt", "r")
password = bz2.decompress(w.read())
w.close()
print password

# remove file, ignore non-existing file
try:
&nbsp;&nbsp; os.unlink("file")
&nbsp;&nbsp; except OSError, e:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if e.errno != errno.ENOENT:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; raise

41 exec system cmds.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

#
def _is_exe( fpath ):
&nbsp;&nbsp;&nbsp; return os.path.exists(fpath) and os.access(fpath, os.X_OK) and os.access(fpath, os.R_OK)


# run python from within bash
export source="hallo"

python &lt;&lt;END

import os

print os.environ['source']
print "VVV", "$target"

END
#
def _is_exe( fpath ):
&nbsp;&nbsp;&nbsp; if os.path.exists(fpath) and os.access(fpath, os.X_OK):


error codes:

&gt;&gt;&gt; import errno
use like
&gt;&gt;&gt; errno.EPERM
1
&gt;&gt;&gt; print os.strerror(1)
Operation not permitted

# files
errno.ENOENT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; No such file or directory
errno.EEXIST&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; File exists
errno.ENOTDIR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Not a directory
errno.EISDIR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Is a directory
errno.ETXTBSY&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Text file busy
errno.ENAMETOOLONG&nbsp; File name too long


# io, memory, devices
errno.EIO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; I/O error
errno.ENOMEM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Out of memory
errno.ENOSPC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; No space left on device
errno.ENXIO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; No such device or address
errno.EROFS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Read-only file system
errno.EDEADLOCK&nbsp;&nbsp;&nbsp;&nbsp; File locking deadlock error
errno.ENOBUFS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; No buffer space available



errno.ESRCH&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; No such process
errno.EINTR&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Interrupted system call
errno.ETIME&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Timer expired
errno.EPERM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Operation not permitted
errno.ELIBACC&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Can not access a needed shared library


# network
errno.ESTALE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Stale NFS file handle
errno.EHOSTUNREACH&nbsp; No route to host
errno.ENETUNREACH&nbsp;&nbsp; Network is unreachable
errno.ECONNABORTED&nbsp; Software caused connection abort
errno.ECONNRESET&nbsp;&nbsp;&nbsp; Connection reset by peer
errno.ETIMEDOUT&nbsp;&nbsp;&nbsp;&nbsp; Connection timed out
errno.ECONNREFUSED&nbsp; Connection refused
errno.EHOSTDOWN&nbsp;&nbsp;&nbsp;&nbsp; Host is down
errno.EFAULT&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Bad address
errno.ENONET&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Machine is not on the network
errno.ECOMM&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Communication error on send
errno.EPROTO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Protocol error
errno.ENOTSOCK&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Socket operation on non-socket
errno.EDESTADDRREQ&nbsp; Destination address required
errno.EREMOTE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object is remote

# general
errno.EACCES&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Permission denied
errno.EAGAIN&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Try again
errno.ENOSYS&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Function not implemented
errno.ENODATA&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; No data available
errno.ENOPKG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Package not installed

# wrapper module for getting a password from the user. Getting a password is accomplished differently on UNIX, Windows, and Mac OS platforms, but this code encapsulates all of those differences.


# Bind the name getpass to the appropriate function
try:
&nbsp;&nbsp;&nbsp;&nbsp; import termios, TERMIOS
except ImportError:
&nbsp;&nbsp;&nbsp;&nbsp; try:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; import msvcrt
&nbsp;&nbsp;&nbsp;&nbsp; except ImportError:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; try:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; from EasyDialogs import AskPassword
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; except ImportError:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getpass = default_getpass
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getpass = AskPassword
&nbsp;&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; getpass = win_getpass
else:

getpass = unix_getpass

&nbsp;&nbsp;&nbsp; # termios is a UNIX-specific module that provides low-level control over the input terminal. If this module is
&nbsp;&nbsp;&nbsp; # not available (because it's not on your system, or your system doesn't support it), the import fails and Python
&nbsp;&nbsp;&nbsp; # raises an ImportError, which you catch.
&nbsp;&nbsp;&nbsp; # OK, you didn't have termios, so let's try msvcrt, which is a Windows-specific module that provides an
&nbsp;&nbsp;&nbsp; # API to many useful functions in the Microsoft Visual C++ runtime services. If this import fails, Python will
&nbsp;&nbsp;&nbsp; # raise an ImportError, which you catch.
&nbsp;&nbsp;&nbsp; # If the first two didn't work, you try to import a function from EasyDialogs, which is a Mac OS-specific
&nbsp;&nbsp;&nbsp; # module that provides functions to pop up dialog boxes of various types. Once again, if this import fails, Python
&nbsp;&nbsp;&nbsp; # will raise an ImportError, which you catch.


# system plattform linux windows feststellen:
if sys.platform == 'linux2':


# system interaction
# print all environment variables known to script
&gt;&gt;&gt; import os
&gt;&gt;&gt; for k, v in os.environ.items():
...&nbsp;&nbsp;&nbsp;&nbsp; print "%s=%s" % (k, v)


&nbsp;&nbsp;&nbsp; for files_filter in [ os.path.join( dir, filter )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for filter in filters
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; for dir in dirs
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ]:

# start system command (simple) read output
&nbsp;&nbsp;&nbsp; for line in os.popen( "xm info").readlines():



# exit handler
# the functions registered via this module are not called when the program is killed by a signal, when a Python fatal internal error is detected, or when os._exit() is called. sys.exit() is ok. register multiple functions if you need to.
import atexit
def sichereEingaben(liste):
&nbsp;&nbsp;&nbsp; open("eingaben.txt", "w").writelines("\n".join(liste))

# Any optional arguments that are to be passed to func must be passed as arguments to register()
atexit.register(sichereEingaben, eingaben)



# command line options
import sys
program_name = sys.argv[0]
arguments = sys.argv[1:]
count = len(arguments)



# parse options:

&nbsp;&nbsp;&nbsp; minArgs = 5 # minimum number of expected arguments (for later use)
&nbsp;&nbsp;&nbsp; parser = OptionParser(add_help_option = False)
&nbsp;&nbsp;&nbsp; parser.add_option( '-g', '--group'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , dest='group'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
&nbsp;&nbsp;&nbsp; parser.add_option( '-m', '--module'&nbsp;&nbsp;&nbsp;&nbsp; , dest='module'&nbsp;&nbsp;&nbsp;&nbsp; )
&nbsp;&nbsp;&nbsp; parser.add_option( '-F', '--config'&nbsp;&nbsp;&nbsp;&nbsp; , dest='configFile' )
&nbsp;&nbsp;&nbsp; parser.add_option( '-h', '--help'&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; , dest='help',&nbsp;&nbsp;&nbsp; action='store_true' )
&nbsp;&nbsp;&nbsp; # analyse command line options
&nbsp;&nbsp;&nbsp; optList, optArgs = parser.parse_args(sys.argv[1:])


&nbsp;&nbsp;&nbsp; # iterate over option - arg values:
&nbsp;&nbsp;&nbsp; for opt in optList.__dict__.items():
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print opt

&nbsp;&nbsp;&nbsp; # all options set: a
&nbsp;&nbsp;&nbsp; a= [ opt[0] for opt in optList.__dict__.items() if opt[1] is not None ]

&nbsp;&nbsp;&nbsp; if len(a) &lt; minArgs:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; tod_und_teufel

# surpress subproccess output
&nbsp;&nbsp;&nbsp; fsck = subprocess.Popen(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; [ "/sbin/e2fsck", "-y", disc_dev ]&nbsp; ,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stdout = open( os.devnull, 'w' )&nbsp;&nbsp;&nbsp; ,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; stderr = open( os.devnull, 'w' )&nbsp;&nbsp;&nbsp; ,
&nbsp;&nbsp;&nbsp; )
&nbsp;&nbsp;&nbsp; ec&nbsp; = fsck.wait()



# signal handling, temp/lock file
#! /usr/local/bin/python
import os
import tempfile
import sys
import signal
t_path = ''
t_file = None
def cleanup(signal, frame):
&nbsp;&nbsp;&nbsp; if t_path != '' and t_file != None:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print 'Cleaning up temporary files ...'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; os.close(t_file)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; os.remove(t_path)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print 'Done!'
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sys.exit(0)
&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sys.exit(0)
signal.signal(signal.SIGHUP, cleanup)
signal.signal(signal.SIGINT, cleanup)
signal.signal(signal.SIGQUIT, cleanup)
signal.signal(signal.SIGTERM, cleanup)
try:
&nbsp;&nbsp;&nbsp; t_path = tempfile.mktemp()
&nbsp;&nbsp;&nbsp; t_file = os.open(t_path, os.O_CREAT | os.O_RDWR)
except IOError:
&nbsp;&nbsp;&nbsp; print 'Error:&nbsp; Couldn\'t create temp file.'
&nbsp;&nbsp;&nbsp; sys.exit(0)
#
# always close and remove the temp file
# before you exit from script
cleanup(t_path, t_file)




# pexpect
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; session = pexpect.spawn( self.RDIFF_EXE, options, timeout=timeout)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; while True:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; out = session.readline()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if out == '':
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; break
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; log.info( out.rstrip() )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; session.close()
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print session.exitstatus
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print session.signalstatus

# handle password dialog via pexpect
child = pexpect.spawn('scp foo myname@host.example.com:.')
child.expect ('Password:')
child.sendline (mypassword)

42 db, ldap.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-


# simple db: sqlite3
db = sqlite3 . connect ( " /var/test/bla.db " )
dbc.execute( """ CREATE TABLE Friends ( vorname TEXT , nachname TEXT ) """ )
dbc.execute( """ INSERT INTO Friends VALUES ( " Max " , " Mueller " ) """ )
db.commit ()


dbc.execute( """ SELECT * FROM Friends """ )
for row in dbc :
&nbsp;&nbsp;&nbsp; print row
dbc.close ()
db.close ()

Yes:
dbc.execute( """... INSERT INTO Frie VALUES = (?,?)""", (var1[, var2]) )

No:
&gt;&gt;&gt; symbol = "Max"
&gt;&gt;&gt; dbc.execute( "... WHERE name = (%s,%s)" % (var1, var2) )


# mysql

aptitude install python-mysqldb

mysql = MySQLdb.connect(
&nbsp;&nbsp;&nbsp; 'localhost',
&nbsp;&nbsp;&nbsp; user,
&nbsp;&nbsp;&nbsp; passwd,
&nbsp;&nbsp;&nbsp; database,
)

cursor = mysql.cursor()
cursor.execute( "SELECT * FROM stations ")


print cursor.fetchall()

#ldap

class LdapUser

&nbsp;&nbsp;&nbsp; # general
&nbsp;&nbsp;&nbsp; uid, nam, gid: single entry or array

__init__
&nbsp; check and store connection parameters
&nbsp;&nbsp;&nbsp; open and close connection at each request


_open()
_close()
_isArray()

getpwall()
# list of tupels for all users under this ldap tree
getpwnam(nam) # single or a
getpwuid(uid)

(name,passwd,uid,gid,gecos,dir,shell)

setpwnam(nam, [attrs])
# in case any parameter is none, leave it like it is, put "" to clear
setpwuid(uid, [attrs])
rempwnam(nam) # single or array
rempwuid(uid) # single or array
existspwnam(nam)
existspwuid(uid)

disablepwnam(nam) # single or array
disablepwuid(uid) # single or array
enablepwnam(nam)&nbsp; # single or array
enablepwuid(uid)&nbsp; # single or array

pwaddgrnam&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # add single entry or array
pwremgrnam&nbsp; # single or array
pwsetgrnam
pwgetgrnam&nbsp; # single or array
pwaddgrgid
pwremgrgid
pwsetgrgid
pwgetgrgid

(name,gid,mem)

getgrall()
# list of tupels for all groups under this ldap tree
getgrnam(name)
# tupel
getgrgid(gid)
# tupel
remgrnam(nam)
remgrgid(gid)
existsgrnam(nam)
existsgrgid(gid)
#handle user membership in group
graddpwuid&nbsp; # add single entry or array
grsetpwuid
grrempwuid
grgetpwuid
graddpwnam
grsetpwnam
grrempwnam
grgetpwnam



if __name__ == "__main__":
&nbsp;&nbsp;&nbsp; import sys
&nbsp;&nbsp;&nbsp; #try:
&nbsp;&nbsp;&nbsp; #useradd( sUserName = 'hbeimer', sHome = '/dev/null' , sShell = '/bin/nologin',&nbsp; )
&nbsp;&nbsp;&nbsp; #useradd( sUserName = 'rbeimer', sHome = '/dev/null' , sShell = '/bin/nologin',&nbsp; )
#&nbsp;&nbsp;&nbsp; #usermod( sUserName = 'hbeimer', sShell = '/bin/bash' )
#&nbsp;&nbsp;&nbsp; userpasswd( 'hbeimer',&nbsp; 'hallo1' )
&nbsp;&nbsp;&nbsp; groupadd( 'hjlh' )
&nbsp;&nbsp;&nbsp; #except Exception, emsg:
&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; print emsg
&nbsp;&nbsp;&nbsp; #&nbsp;&nbsp;&nbsp; sys.exit(1)
&nbsp;&nbsp;&nbsp; #addgroupstouser( 'hbeimer', [ 'rbeimer', 'hbeimer'] )


44 rpc.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-
# xmlrpc server

from SimpleXMLRPCServer import SimpleXMLRPCServer
# Methoden , die der Server zur Verfuegung
# stellen soll :
class MyFuncs :
&nbsp;&nbsp;&nbsp; def add ( self , x , y ):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x + y
&nbsp;&nbsp;&nbsp; def sub ( self , x , y ):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return x - y
# Erstelle und starte Server :
server = SimpleXMLRPCServer(("localhost", 8000))
server.register_instance(MyFuncs())
server.serve_forever()

# xmlrpc client
import xmlrpclib
s = xmlrpclib.Server("http://localhost:8000")
print s.add(2 ,3)
print s.sub(5 ,2)





# remote execution (assume remote rpyc running) - call any functions or classes available on those machines
# wrap with tlslite for security
&gt;&gt;&gt; use rpyc
&gt;&gt;&gt; connGlarp = rpyc.classic.connect("71.218.122.169")
&gt;&gt;&gt; connGlarp.modules.os.uname()
('FreeBSD', 'antediluvian.glarp.com', '6.1-RELEASE',
'FreeBSD 6.1-RELEASE #0: Fri Jul 18 00:01:34 MDT 2008;
root@antediluvian.glarp.com:/usr/src/sys/i386/compile/ANTEDILUVIAN',
'i386')

# asynchronius calls (do something while server works)
asleep = rpyc.async(conn.modules.time.sleep)
resource = asleep(15)
# check if finished
&gt;&gt;&gt; resource.ready # True, False


# run local code remotely: possible


# Classic mode is just a service that exposes everything on the remote system, but you can build services that expose just a few things in a small number of lines of code
import rpyc
class DoStuffService(rpyc.Service):
&nbsp;&nbsp; def on_connect(self):
&nbsp;&nbsp;&nbsp; "Do some things when a connection is made"
&nbsp;&nbsp; def on_disconnect(self):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Do some things AFTER a connection is dropped"
&nbsp;&nbsp; def exposed_func1(self, *args, **kws):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Do something useful and maybe return a value"
&nbsp;&nbsp; def exposed_func2(self, *args, **kws):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; "Like func1, but do something different"

if __name__ == '__main__':
&nbsp;&nbsp; rpyc.utils.server.ThreadedServer(DoStuffService).start()

# From a client, this service is just like the classic mode server, except all it exposes is the methods that are prefixed by exposed_ (minus the prefix). Trying to access other methods (such as builtin modules) will fail. So a client might look like this:
&gt;&gt;&gt; import rpyc
&gt;&gt;&gt; conn = rpyc.connect('dostuff.example.com')
&gt;&gt;&gt; myval = conn.root.func1()&nbsp;&nbsp; # Special 'root' of connection
&gt;&gt;&gt; local_computation(myval)

46 logging.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-




# log level info: everything worth showing up in logs
# log level debug: needed information when things go wrong or during development
# warnings: log.warning
# errors: raise exceptions, logging gets done from callers perspective
# all othe

# module logging
# on top of each module, define some larifari logger:
# important: set logger name here so messages can be filtered in parent

&nbsp;&nbsp;&nbsp; # example module
&nbsp;&nbsp;&nbsp; import logging
&nbsp;&nbsp;&nbsp; log = logging.getLogger( __name__ )
&nbsp;&nbsp;&nbsp; class Class()

# do ot overwrite callers log instance by importet module
YES:
&nbsp;&nbsp;&nbsp; import module
&nbsp;&nbsp;&nbsp; instance = module.Class()
NO:
&nbsp;&nbsp;&nbsp; from module import *
&nbsp;&nbsp;&nbsp; instance=Class()


# exceptions: do not log exceptions but let parent module handle logging
NO:
&nbsp;&nbsp;&nbsp; msg = "could not do anything"
&nbsp;&nbsp;&nbsp; log.error(msg)
&nbsp;&nbsp;&nbsp; raise SorryError( msg)

&nbsp;&nbsp;&nbsp; # but
YES:
&nbsp;&nbsp;&nbsp; msg = "could not do anything"
&nbsp;&nbsp;&nbsp; raise SorryError( msg)






Example:

# for running module, define logging like
if __name__ == "__main__":
&nbsp;&nbsp;&nbsp; import sys
&nbsp;&nbsp;&nbsp; import os
&nbsp;&nbsp;&nbsp; import logging

&nbsp;&nbsp;&nbsp; log = logging.getLogger()

&nbsp;&nbsp;&nbsp; # debug logging
&nbsp;&nbsp;&nbsp; logging.basicConfig(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; level&nbsp;&nbsp;&nbsp; = logging.DEBUG&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datefmt&nbsp; = "%Y-%m-%d %H:%M:%S"&nbsp; ,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; format&nbsp;&nbsp; = "%(asctime)-20s %(levelname)-8s%(name)s:%(funcName)" \
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; + "s[%(lineno)d]\t%(message)s"&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #filename = ""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,
&nbsp;&nbsp;&nbsp; )

&nbsp;&nbsp;&nbsp; # standard logging
&nbsp;&nbsp;&nbsp; logging.basicConfig(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; level&nbsp;&nbsp;&nbsp; = logging.INFO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datefmt&nbsp; = "%Y-%m-%d %H:%M:%S"&nbsp; ,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; format&nbsp;&nbsp; = "%(asctime)-20s %(levelname)-8s%(name)s\t%(message)s",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #filename = ""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,
&nbsp;&nbsp;&nbsp; )


&nbsp;&nbsp;&nbsp; # short logging
&nbsp;&nbsp;&nbsp; logging.basicConfig(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; level&nbsp;&nbsp;&nbsp; = logging.INFO&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; datefmt&nbsp; = "%Y-%m-%d %H:%M:%S"&nbsp; ,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; format&nbsp;&nbsp; = "%(asctime)-20s %(message)s",
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; #filename = ""&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; ,
&nbsp;&nbsp;&nbsp; )
==============

# log to file vers 1:
import logging
import logging.handlers

LOG_FILENAME = '/tmp/logging_rotatingfile_example.out'

# Set up a specific logger with our desired output level
my_logger = logging.getLogger('MyLogger')
my_logger.setLevel(logging.DEBUG)

# Add the log message handler to the logger
handler = logging.handlers.RotatingFileHandler(
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; LOG_FILENAME, maxBytes=20, backupCount=5
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; )
my_logger.addHandler(handler)



# log to file vers. 2:
import logging
logging.basicConfig (
&nbsp;&nbsp;&nbsp; level&nbsp;&nbsp;&nbsp; = logging.DEBUG,
&nbsp;&nbsp;&nbsp; format&nbsp;&nbsp; = "%(asctime)s %(levelname)-8s %(message)s" ,
&nbsp;&nbsp;&nbsp; datefmt&nbsp; = "%Y-%m-%d %H:%M:%S" ,
&nbsp;&nbsp;&nbsp; filename = '/tmp/spam.log',
&nbsp;&nbsp;&nbsp; filemode = 'w',
)
logging.debug(&nbsp;&nbsp; "Very special information." )
logging.info(&nbsp;&nbsp;&nbsp; "I am doing this and that." )
logging.warning( "You should know this."&nbsp;&nbsp;&nbsp;&nbsp; )
# CRITICAL, ERROR, EXCEPTION, WARNING, INFO, DEBUG

log.DEBUG
&nbsp;&nbsp;&nbsp; Detailed information, typically of interest only when diagnosing problems.
log.INFO
&nbsp;&nbsp;&nbsp; Confirmation that things are working as expected.
log.WARNING
&nbsp;&nbsp;&nbsp; An indication that something unexpected happened, or indicative of some problem in the near future (e.g. "disk space low"). The software is still working as expected.
log.ERROR
&nbsp;&nbsp;&nbsp; Due to a more serious problem, the software has not been able to perform some function. This should be a catched expression.
log.CRITICAL
&nbsp;&nbsp;&nbsp; A serious error, indicating that the program itself may be unable to continue running.&nbsp; This should be a catched expression.

msg.plain(text)
&nbsp;&nbsp;&nbsp; Display console output for ordinary usage of a command line script or program


EXCEPTION
&nbsp;&nbsp;&nbsp; Report an error regarding a particular runtime event

in modules
==========
&nbsp;&nbsp;&nbsp; * no print allowed, yield/return values and raise exceptions

in scripts (module caller, frontend app):
=========================================
&nbsp;&nbsp;&nbsp; * print output, yield/return values to os, capture exceptions (print &amp; exit)

verbosity levels
================

-qq&nbsp;&nbsp; errors, critical
-q&nbsp;&nbsp;&nbsp; warnings, errors, critical
-&nbsp;&nbsp;&nbsp;&nbsp; print
-v&nbsp;&nbsp;&nbsp; log.info, print_ok, print_err, print_warn, print_start
-vv&nbsp;&nbsp; log.debug



50 config file.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-


# simple config file
config = ConfigParser.ConfigParser()
config.read( config_file )
config.get( 'Server', 'Host' )


# advanced config file parsing



#=============================================================================
# test structure
#=============================================================================
if __name__ == "__main__":
&nbsp;&nbsp;&nbsp; import sys
&nbsp;&nbsp;&nbsp; try:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; config = ConfigFile( "test" )
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print config
&nbsp;&nbsp;&nbsp; except ConfigFileError, emsg:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print emsg
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; sys.exit(1)

&nbsp;&nbsp;&nbsp; config.read()
&nbsp;&nbsp;&nbsp; print config
&nbsp;&nbsp;&nbsp; config['Hallo4'] = {}
&nbsp;&nbsp;&nbsp; config['Hallo4']['mick1'] = 'jjj'
&nbsp;&nbsp;&nbsp; config['Hallo4']['mick7'] = [ 'hhhh', 'jjjj', 'hallo', ]

#&nbsp;&nbsp;&nbsp; config.purgVe()
&nbsp;&nbsp;&nbsp; print config
&nbsp;&nbsp;&nbsp; config.write()
&nbsp;&nbsp;&nbsp; print config.as_bool('DefaultSFtp')
52 net.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

# test if ip:port is open
import socket

def isOpen(ip,port):
&nbsp;&nbsp;&nbsp; s = socket.socket(socket.AF_INET, socket.SOCK_STREAM)
&nbsp;&nbsp;&nbsp; try:
&nbsp;&nbsp;&nbsp;&nbsp; s.connect((ip, int(port)))
&nbsp;&nbsp;&nbsp;&nbsp; s.shutdown(2)
&nbsp;&nbsp;&nbsp;&nbsp; return True
&nbsp;&nbsp;&nbsp; except:
&nbsp;&nbsp;&nbsp;&nbsp; return False


# sort ip's
def compare_ips(x, y):

&nbsp;&nbsp;&nbsp; # split and transfer ip segements to integer
&nbsp;&nbsp;&nbsp; x1, x2, x3, x4 = [ int(z) for z in x[0].split('.') ]
&nbsp;&nbsp;&nbsp; y1, y2, y3, y4 = [ int(z) for z in y[0].split('.') ]

&nbsp;&nbsp;&nbsp; # do comparison
&nbsp;&nbsp;&nbsp; if&nbsp;&nbsp; x1 &gt; y1: return&nbsp; 1
&nbsp;&nbsp;&nbsp; elif x1 &lt; y1: return -1
&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;&nbsp; x2 &gt; y2: return&nbsp; 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif x2 &lt; y2: return -1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;&nbsp; x3 &gt; y3: return&nbsp; 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif x3 &lt; y3: return -1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; if&nbsp;&nbsp; x4 &gt; y4: return&nbsp; 1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; elif x4 &lt; y4: return -1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; else:
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return 0

def sortedIps( ips ):
&nbsp;&nbsp;&nbsp; return sorted( ips, cmp=compare_ips)

53 users, groups.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-


#&nbsp;&nbsp;&nbsp;&nbsp; get all group id's where user is member off (missing: own group id)
import grp
print [ entry[2] for entry in grp.getgrall() if 'srv' in entry [3] ]

# get uid/gid id for user name
import grp
import pwd
self.uid = pwd.getpwnam(user )[2]
self.gid = grp.getgrnam(group)[2]


80 classes methods functions.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-


# dir returns a list of the attributes and methods of any object: modules, functions, strings, lists, dictionaries
# to find all the methods which work on a dictionary, do
&gt;&gt;&gt; d = {}
&gt;&gt;&gt; dir(d)
['clear', 'copy', 'get', 'has_key', 'items', 'keys', 'setdefault', 'update', 'values']

# functions are objects, too



# subclassing
# in case a method must be subclassed: define&nbsp; spaceholder method in parent:
def subclass_me(self):
&nbsp;&nbsp;&nbsp; raise NotImplementedError("Subclass must implement abstract method")



# getattr
returns a reference (handle) to any object, a reference to a handle *is* the function itself
getattr(li, "pop") # gets a reference to the pop method of the list, method name is a simple string

# call a method by name in variable:
&nbsp;&nbsp;&nbsp; import amodule
&nbsp;&nbsp;&nbsp; varstring='f'
&nbsp;&nbsp;&nbsp; function=getattr(amodule,varstring)
&nbsp;&nbsp;&nbsp; function()

&nbsp;&nbsp;&nbsp; # or
&nbsp;&nbsp;&nbsp; def output(data, format="text"):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # object(here: module), method(string)[, default string])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; output_function = getattr(statsout, "output_%s" % format, output_text)
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return output_function(data)



# callable
# takes any object and returns True if the object can be called, or False otherwise.


# inherit dynamically from multiple class
class Slave1(object):
&nbsp;&nbsp;&nbsp; t1="1"
class Slave2(object):
&nbsp;&nbsp;&nbsp; t2="2"

class MetaClass(type):
&nbsp;&nbsp;&nbsp; def __new__(meta, classname, bases, classDict):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; bases = tuple([Slave1, Slave2])
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return type.__new__(meta, classname, bases, classDict)

class Master(object):
&nbsp;&nbsp;&nbsp; __metaclass__ = MetaClass

m=Master()
print m.t1
print m.t2


# functions
info(spacing=15, object=odbchelper)
or
info(15,odbchelper)


# lambda-functions
#&nbsp; define one-line mini-functions on the fly, define a separate normal function and use that instead. I use them in places where I want to encapsulate specific, non-reusable code without littering my code with a lot of little one-line functions.

&gt;&gt;&gt; def f(x):
...&nbsp;&nbsp;&nbsp;&nbsp; return x*2
...
&gt;&gt;&gt; f(3)
6
&gt;&gt;&gt; g = lambda x: x*2
&gt;&gt;&gt; g(3)
6


# nesting functions
# nested functions can be called only from the function in which it is defined


# *args, **kwargs
def __init__(self, filename, **kw):
&nbsp;&nbsp;&nbsp; """ The constructor takes the filename and some options.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; backup -- boolean indicating whether you want a backup file
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; (default is yes)
&nbsp;&nbsp;&nbsp; """
&nbsp;&nbsp;&nbsp; self.filename = filename
&nbsp;&nbsp;&nbsp; self.do_backup = kw.get('backup', 1)

&nbsp;&nbsp;&nbsp; self.stream = None
&nbsp;&nbsp;&nbsp; self.basename, ext = os.path.splitext(self.filename)


# Beispiel mit klassen:

# elternklasse mit einigen defaults

class BwLimit:
&nbsp;&nbsp;&nbsp; BS_START = 1 * 102
&nbsp;&nbsp;&nbsp; BS_MAX&nbsp;&nbsp; = 4 * 1024
&nbsp;&nbsp;&nbsp; CHECK_INTERVAL = 600

&nbsp;&nbsp;&nbsp; def __init__(self, check_interval=CHECK_INTERVAL, bs_start=BS_START, bs_max=BS_MAX , *args, **kwargs):


# child klasse
class PipeBwLimit(BwLimit):
&nbsp;&nbsp;&nbsp; PIPE_BS_MAX&nbsp;&nbsp; = 64 * 1024
&nbsp;&nbsp;&nbsp; PIPE_BS_START = 4 * 1024
&nbsp;&nbsp;&nbsp; def __init__(self, bs_max=PIPE_BS_MAX, bs_start=PIPE_BS_START, *args, **kwargs):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; BwLimit.__init__(self,bs_max=bs_max, bs_start=bs_start, *args, **kwargs)


if __name__ == '__main__':
&nbsp;&nbsp;&nbsp; pbwl = PipeBwLimit(bw_max = 1024)



# lists as positional parameters
&gt;&gt;&gt; args = [3, 6, 2, 3]
&gt;&gt;&gt; spam (*args)
3 6 2 3

# use dictionaries as keyword - parameters
&gt;&gt;&gt; kwargs = {"c" : 5, "a" : 2, "b" : 4, "d" :1}
&gt;&gt;&gt; spam (**kwargs)
2 4 5 1

# all together (mixed parameters)
def spam (* args, **kwargs):
&nbsp;&nbsp;&nbsp; for i in args :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print i
&nbsp;&nbsp;&nbsp; for i in kwargs :
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; print i, kwargs[i]

&gt;&gt;&gt; spam (1, 2, c=3, d=4)
1
2
c 3
d 4



# classes
# inherit anchestor modules
from UserDict import UserDict
class FileInfo(UserDict):

# constructor - like first method
class FileInfo(UserDict):
&nbsp;&nbsp;&nbsp; "store file metadata"
&nbsp;&nbsp;&nbsp; def __init__(self, filename=None):&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # override "constructor" class of UserDict class
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; UserDict.__init__(self)&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # call "constructor" of anchestor class
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self["name"] = filename&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # assign the argument filename as the value of this object's name key

# Instantiating classes in Python is straightforward. To instantiate a class, simply call the class as if it were a function, passing the arguments that the __init__ method defines. The return value will be the newly created object.

# private objects
everything starting with "__"
# If you try to call a private method, Python will raise a slightly misleading exception, saying that the method does not exist. Of course it does exist, but it's private, so it's not accessible outside the class.


# modify "return value" for classes (what you get by calling c = ExampleClass() )
class ExampleClass:
&nbsp;&nbsp;&nbsp; def __str__ ( self ):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return "my return"
&gt;&gt;&gt; print c
"my return"

# class variables: * same value for each instance
class ExampleClass:
&nbsp;&nbsp;&nbsp; anzahl = 0
&nbsp;&nbsp;&nbsp; def __init__(self):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; self.__class__.anzahl += 1&nbsp; # instances counter


# TODO
# properties, static methods, class methods, decorators


# setup.py
# Install script for ConfigObj
# Copyright (C) 2005-2010 Michael Foord, Mark Andrews, Nicola Larosa
# E-mail: fuzzyman AT voidspace DOT org DOT uk
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mark AT la-la DOT com
#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; nico AT tekNico DOT net

# This software is licensed under the terms of the BSD license.
# http://www.voidspace.org.uk/python/license.shtml

import sys
from distutils.core import setup
from configobj import __version__ as VERSION

NAME = 'configobj'

MODULES = 'configobj', 'validate'

DESCRIPTION = 'Config file reading, writing and validation.'

URL = 'http://www.voidspace.org.uk/python/configobj.html'

DOWNLOAD_URL = "http://www.voidspace.org.uk/downloads/configobj-%s.zip" % VERSION

LONG_DESCRIPTION = """**ConfigObj** is a simple but powerful config file reader and writer: an *ini
file round tripper*. Its main feature is that it is very easy to use, with a
straightforward programmer's interface and a simple syntax for config files.
It has lots of other features though :

* Nested sections (subsections), to any level
* List values
* Multiple line values
* Full Unicode support
* String interpolation (substitution)
* Integrated with a powerful validation system

&nbsp;&nbsp;&nbsp; - including automatic type checking/conversion
&nbsp;&nbsp;&nbsp; - and allowing default values
&nbsp;&nbsp;&nbsp; - repeated sections

* All comments in the file are preserved
* The order of keys/sections is preserved
* Powerful ``unrepr`` mode for storing/retrieving Python data-types

| Release 4.7.2 fixes several bugs in 4.7.1
| Release 4.7.1 fixes a bug with the deprecated options keyword in
| 4.7.0.
| Release 4.7.0 improves performance adds features for validation and
| fixes some bugs."""

CLASSIFIERS = [
&nbsp;&nbsp;&nbsp; 'Development Status :: 6 - Mature',
&nbsp;&nbsp;&nbsp; 'Intended Audience :: Developers',
&nbsp;&nbsp;&nbsp; 'License :: OSI Approved :: BSD License',
&nbsp;&nbsp;&nbsp; 'Programming Language :: Python',
&nbsp;&nbsp;&nbsp; 'Programming Language :: Python :: 2.3',
&nbsp;&nbsp;&nbsp; 'Programming Language :: Python :: 2.4',
&nbsp;&nbsp;&nbsp; 'Programming Language :: Python :: 2.5',
&nbsp;&nbsp;&nbsp; 'Programming Language :: Python :: 2.6',
&nbsp;&nbsp;&nbsp; 'Operating System :: OS Independent',
&nbsp;&nbsp;&nbsp; 'Topic :: Software Development :: Libraries',
&nbsp;&nbsp;&nbsp; 'Topic :: Software Development :: Libraries :: Python Modules',
]

AUTHOR = 'Michael Foord &amp; Nicola Larosa'

AUTHOR_EMAIL = 'fuzzyman@voidspace.org.uk'

KEYWORDS = "config, ini, dictionary, application, admin, sysadmin, configuration, validation".split(', ')


setup(name=NAME,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; version=VERSION,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; description=DESCRIPTION,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; long_description=LONG_DESCRIPTION,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; download_url=DOWNLOAD_URL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; author=AUTHOR,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; author_email=AUTHOR_EMAIL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; url=URL,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; py_modules=MODULES,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; classifiers=CLASSIFIERS,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; keywords=KEYWORDS
&nbsp;&nbsp;&nbsp;&nbsp; )
90 style guide.txt
=================================
#!/usr/bin/env python
# -*- coding: utf-8 -*-

General
=======
see: http://www.python.org/dev/peps/pep-0008/
try: &gt;&gt;&gt; import this


Code Layout
===========
Indentation
&nbsp; * write max. 79 cols. just do it. reads better. can put two windows side-by
&nbsp;&nbsp;&nbsp; side
&nbsp; * limit flowing long blocks of text (docstrings or comments) to 72 chars
&nbsp; * functions should not span more than 30-50 lines - just fill one window
&nbsp; * separate classes: 2 blank lines
&nbsp; * separate methods: 1 blank line
&nbsp; * http://www.python.org/dev/peps/pep-0008/:
&nbsp;&nbsp;&nbsp; Code is much more read than it is written!


Blank Lines
&nbsp; * top-level functions, classes: 2 lines
&nbsp; * One blank line between functions.
&nbsp; * Two blank lines between classes.
&nbsp; * sparingly separate groups of methods by 1 extra line
&nbsp; * Python accepts the control-L (i.e. ) which is page sep for many tools




Whitespace in Expressions and Statements
&nbsp;&nbsp;&nbsp; Yes: spam(ham[1], {eggs: 2})
&nbsp;&nbsp;&nbsp; No: spam( ham[ 1 ], { eggs: 2 } )

&nbsp;&nbsp;&nbsp; Yes: if x == 4: print x, y; x, y = y, x
No: if x == 4 : print x , y ; x , y = y , x


Yes: spam(1)
No: spam (1)


use spaces around arithmetic operators

do not use whitespace around arguments
Yes: def complex(real, imag=0.0):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return magic(r=real, i=imag)
No: def complex(real, imag = 0.0):
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; return magic(r = real, i = imag)


Comments
========
&nbsp; * write full sentencesstarting with capital (except from identifiers
&nbsp;&nbsp;&nbsp; beginning with lower case letter)
&nbsp; * short comments: no .
&nbsp; * block comments: allways .
&nbsp; * indent # ... comments like the following code
&nbsp; * separate pargraphs in block comments by lin containing single #

Docstrings
==========
&nbsp; * docstring becomes the __doc__ special attribute of that object
&nbsp; * scripts/ standalone prog docstring
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * this is the usage message, print when --help option is choosen
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * document function, cmd line options, env vars and files for script
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * may expand several pages and should be sufficient for a new user to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; use the command properly, as well as a complete quick reference to
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; all options and arguments for the sophisticated user
&nbsp;&nbsp; * module docstring
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * list classes, exceptions and functions exported by module, one line
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; summary of each
&nbsp;&nbsp;&nbsp; * class docstring
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * behaviour, effect, public methods and instance variables
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * list subclassing interface(s) and overridden functions
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * class constructor should be documented in __init__ docstring
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * "override": subclass method replaces superclass method
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * "extend": subclass calls superclass method
&nbsp;&nbsp;&nbsp; * method, function docstring
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * prescribe functions effect as command "do this, return that"
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * effect, behaviour, arguments, return values, side effects,
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; exceptions, restrictions when method/function can be called
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; * indicate optional arguments
&nbsp; * one - line """Doc string full sentence."""
&nbsp; * multiliner
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Summary line.

&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line1
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; line2
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; """



Naming conventions
==================
&nbsp;&nbsp;&nbsp; * _xxx&nbsp; internal function, not imported via from module import *
&nbsp;&nbsp;&nbsp; * __xx&nbsp; method which shall not be found at class inheritation
&nbsp;&nbsp;&nbsp; * xxx_ avoid conflicts with internal keyword
&nbsp;&nbsp;&nbsp; * variables:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; lower_case, do not use l I O as single var names
&nbsp;&nbsp;&nbsp; * constants:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; MAX_HIRE&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # common
&nbsp;&nbsp;&nbsp; * packages, modules:&nbsp; lower_case&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # Pep8
&nbsp;&nbsp;&nbsp; * classes,exceptions: CapWords&nbsp; (+ "Error") # Pep8
&nbsp;&nbsp;&nbsp; * functions:&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; mixedCase&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; # separate them from variables

Some Names
==========
&nbsp;&nbsp;&nbsp; Vererbung = Inheritation

&nbsp;&nbsp;&nbsp; user&nbsp; = usr
&nbsp;&nbsp;&nbsp; group = grp
&nbsp;&nbsp;&nbsp; other = otr
&nbsp;&nbsp;&nbsp; owner = onr

&nbsp;&nbsp;&nbsp; * method names (aka lvm)
&nbsp;&nbsp;&nbsp; create
&nbsp;&nbsp;&nbsp; change
&nbsp;&nbsp;&nbsp; update
&nbsp;&nbsp;&nbsp; remove
&nbsp;&nbsp;&nbsp; rename
&nbsp;&nbsp;&nbsp; read
&nbsp;&nbsp;&nbsp; get
&nbsp;&nbsp;&nbsp; set
&nbsp;&nbsp;&nbsp; add
&nbsp;&nbsp;&nbsp; rem






# function and classes print output
&nbsp;&nbsp;&nbsp; * in general, do not print anything from within modules or class
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; definitions. Errors are communicated via Exceptions.
&nbsp;&nbsp;&nbsp; * all printing in modules can be done by log.debug( text ) after defining
&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; some logger and handler


# build strings in source code
# no! :
x = "line1" + \ # cannot use comments!
"line2"+ \
"line3"

# do:
x = (
"line1" # can use comments
"line2"
"line3"
)



"""
Douglas McIlroy, der Erfinder der Unix-Pipes, fasste die Philosophie folgendermaßen zusammen:

* Schreibe Computerprogramme so, dass sie nur eine Aufgabe erledigen und diese gut machen.
* Schreibe Programme so, dass sie zusammenarbeiten.
* Schreibe Programme so, dass sie Textströme verarbeiten, denn dies ist eine universelle Schnittstelle.

Gewöhnlich wird das verkürzt zu: „Mache nur eine Sache und mache sie gut.“

Von diesen drei Lehrsätzen sind vor allem die ersten beiden nicht auf Unix beschränkt, jedoch betonen Unix-Programmierer alle drei Lehrsätze stärker als andere Programmierer.
"""



"""
It should not be necessary to stress the importance scaling down; nevertheless, a lot of people are obsessed with features and concerned with the possibility of scaling up, forgetting the equally important issue of scaling down. This is an old meme in the computing world: programs should address the common cases simply and simple things should be kept simple, while at the same keeping difficult things possible. plac adhere as much as possible to this philosophy and it is designed to handle well the simple cases, while retaining the ability to handle complex cases by relying on the underlying power of argparse.
"""

"""
If you feel the need for speed, go for built-in functions - you can't beat a loop written in C. Check the library manual for a built-in function that does what you want. If there isn't one, here are some guidelines for loop optimization:

&nbsp;&nbsp;&nbsp; Rule number one: only optimize when there is a proven speed bottleneck. Only optimize the innermost loop. (This rule is independent of Python, but it doesn't hurt repeating it, since it can save a lot of work. :-)
&nbsp;&nbsp;&nbsp; Small is beautiful. Given Python's hefty charges for bytecode instructions and variable look-up, it rarely pays off to add extra tests to save a little bit of work.
&nbsp;&nbsp;&nbsp; Use intrinsic operations. An implied loop in map() is faster than an explicit for loop; a while loop with an explicit loop counter is even slower.
&nbsp;&nbsp;&nbsp; Avoid calling functions written in Python in your inner loop. This includes lambdas. In-lining the inner loop can save a lot of time.
&nbsp;&nbsp;&nbsp; Local variables are faster than globals; if you use a global constant in a loop, copy it to a local variable before the loop. And in Python, function names (global or built-in) are also global constants!
&nbsp;&nbsp;&nbsp; Try to use map(), filter() or reduce() to replace an explicit for loop, but only if you can use a built-in function: map with a built-in function beats for loop, but a for loop with in-line code beats map with a lambda function!
&nbsp;&nbsp;&nbsp; Check your algorithms for quadratic behavior. But notice that a more complex algorithm only pays off for large N - for small N, the complexity doesn't pay off. In our case, 256 turned out to be small enough that the simpler version was still a tad faster. Your mileage may vary - this is worth investigating.
&nbsp;&nbsp;&nbsp; And last but not least: collect data. Python's excellent profile module can quickly show the bottleneck in your code. if you're considering different versions of an algorithm, test it in a tight loop using the time.clock() function.
"""
</pre>



</body></html>