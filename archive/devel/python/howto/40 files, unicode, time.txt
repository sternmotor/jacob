#!/usr/bin/env python
# -*- coding: utf-8 -*-

#UNICODE
# default Python 2 encoding is 'ascii'
# decode early, unicode everywhere, encode late
s.decode('utf-8') # read from disc or user input
    * <type 'str'> to <type 'unicode'>
u.encode('utf-8') # when writing to disc or print
    * <type 'unicode'> to <type 'str'>


# replace everything not a-z0-9 by '_' after converting ÄÖÜäöüß 

def renice( name = None ):
    name1 = re.sub( '\\xf6', 'oe',  name.lower()  )
    name2 = re.sub( '\\xe4', 'ae',  name1  )
    name3 = re.sub( '\\xfc', 'ue',  name2  )
    name4 = re.sub( '\\xdf', 'ss',  name3  )
    return  re.sub( '[^a-z0-9]', '_',  name4  )


# UnicodeEncodeError bei print Ausgabe: Python nimmt für stdout standardmäßig ascii an, läßt sich mit 
print sys.stdout.encoding 

# anzeigen. sys.stdout.encoding ist ro aber läßt sich folgendermaßen setzen
sys.stdout = codecs.getwriter('UTF-8')(sys.stdout)



# file operation
datei2 = open ( " / tmp / eggs " , " wb " )
r, w, b=binary, a=append, r+=rw
f.read                  # read whole file
f.readline              # read one line
f.write(string)         # write to file
f.writelines(sequence)  # write array/tupel to file, terminate lines by '\n'
f.close                 # close file

# read file line by line (using generator for eventually huge files)
    proc_mounts_fh = open( MOUNT_LIST, 'r')  
    for line in proc_mounts_fh.xreadlines():
        print line,                        
    proc_mounts_fh.close() 


# touch a file
    # set time of existing file:
    os.utime( path, None)

    # create not existing file
    open(path, 'w').close()


# make sure line exists in file
    # make sure nobody is in sudoers file
    sudoers_line = """nobody ALL = NOPASSWD: /bin/ip route *""" 
    for line in open( SUDOERS_FILE, 'r' ).readlines():
        if line.find( sudoers_line ) > -1:
            break
    else:
        fh_sudoers = open( SUDOERS_FILE, 'a' )
        fh_sudoers.write( sudoers_line + "\n" )
        fh_sudoers.close()




# os.path
path = os.path.normpath(self.path)
    if os.path.isabs(path):
        path = path[1:]    # safe assumption due to normpath above


realpath(path)          # resolve symlinks
join(path1 path2)       # concentate proper path
splitext(path)          # get path extension
isfile(path)
isdir(path)
islink(path)
getcdw()                # get current work dir
chmod(path, mode)       # mode = 0744 or
                        # stat.S_IRUSR 
    
chown(path, uid, gid)   # numerical uid, gid!
makedirs(path, [mode]   
remove(path)
removedirs(path)
rmtree                  # recursively
rename(src, dst)        # rename 
move(src,dst)           # move recursively

listdir(path)           # all files in dir
glob.iglob('/tmp/*.tmp')     # generator for walking entries by shell glob
copy(src,dst)           # for files and dirs
copytree(src,dst[, symlinks])       # recursively

# split a path into dir and filename from full_path
(dirpath, filename) = os.path.split(full_path)
# get all members of path
path_parts = full_path.split( os.sep ) 



# test if file is accessible (may not work with acls on network file systems)
    if os.access("some-filename", os.W_OK)
    if os.access("some-filename", os.R_OK)
    if os.access("some-filename", os.X_OK)

# create pathes (mkpath)
    os.makedirs ( sPath )



# siehe rdiff.scheduler()

# simple pipe handler, read 256 bytes at once

#! /usr/local/bin/python
import sys
while 1:
    data = sys.stdin.read(256)
    if data != '':
        # do some processing of the contents of
        # the data variable
        data = '#'+data
        # end of data processing command group
        sys.stdout.write(data)
    else:
        sys.stdout.flush()
        break

for line in sys.stdin.readlines():
    print line


# signal handling, temp/lock file
# signal handling, temp/lock file
#! /usr/local/bin/python
import os
import tempfile
import sys
import signal
t_path = ''
t_file = None
def cleanup(signal, frame):
    if t_path != '' and t_file != None:
        print 'Cleaning up temporary files ...'
        os.close(t_file)
        os.remove(t_path)
        print 'Done!'
        sys.exit(0)
    else:
        sys.exit(0)
signal.signal(signal.SIGHUP, cleanup)
signal.signal(signal.SIGINT, cleanup)
signal.signal(signal.SIGQUIT, cleanup)
signal.signal(signal.SIGTERM, cleanup)
try:
    t_path = tempfile.mktemp()
    t_file = os.open(t_path, os.O_CREAT | os.O_RDWR)
except IOError:
    print 'Error:  Couldn\'t create temp file.'
    sys.exit(0)
#
# always close and remove the temp file
# before you exit from script
cleanup(t_path, t_file)




# compress and decompress data to file
import bz2
f=open("test.txt", "w")
f.write(bz2.compress("mypassword"))
f.close()
w = open("test.txt", "r")
password = bz2.decompress(w.read())
w.close()
print password  

# remove file, ignore non-existing file
try:
   os.unlink("file")
   except OSError, e:
      if e.errno != errno.ENOENT:
            raise

