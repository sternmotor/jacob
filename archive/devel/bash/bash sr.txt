Diese Seiten müssen noch komplett überarbeitet werden, Vorlage: Powershell
INHALTSVERZEICHNIS

{{ page.toc }}

EINLEITUNG

Mit Bash lassen sich sehr gut kleine Hilfskripte bauen, welche sequentielles Abarbeiten von Schritten automatisieren. Vorteilhaft ist die Einbindung schneller C-Programme mit bekannten Optionen, problematisch sind die Fehlerbehandlung und komplexere Skriptstrukturen (hier wird Bash langsam). Ab 500 Zeilen Code sollte auf eine "größere" Sprache umgeschwenkt werden.

That "Advanced Bash-Scripting Guide" isn't a very good guide - it's wrong about a lot of things and encourages some poor scripting practices. the Bash FAQ at mywiki.wooledge.org/BashFAQ is much better resource.
http://cheat.errtheblog.com/s/bash
http://www.shell-tips.com
KONSOLE KEYBOARD SHORTCUTS

Control Key combinations (CTRL+KEY)
   Ctrl + a : jump to the start of the line
   Ctrl + c : terminate the command
   Ctrl + d : delete from under the cursor
   Ctrl + e : jump to the end of the line
   Ctrl + k : delete to EOL
   Ctrl + l : clear the screen
   Ctrl + r : search the history backwards
   Ctrl + R : search the history backwards with multi-occurrence
   Ctrl + u : delete backward from cursor
   Ctrl + w : delete backward a word
   Ctrl + xx : move between EOL and current cursor position
   Ctrl + z : suspend/stop the command
Alt Key combinations (ALT+KEY)
   Alt + < : move to the first line in the history
   Alt + > : move to the last line in the history
   Alt + ? : show current completion list
   Alt + * : insert all possible completions
   Alt + / : attempt to complete filename
   Alt + . : yank last argument to previous command
   Alt + b : move backward
   Alt + c : capitalize the word
   Alt + d : delete word
   Alt + f : move forward
   Alt + l : make word lowercase
   Alt + n : search the history forwards non-incremental
   Alt + p : search the history backwards non-incremental
   Alt + r : recall command
   Alt + t : move words around
   Alt + u : make word uppercase
   Alt + Backspace : delete backward from cursor
Escape Key combinations (ESC+KEY)
   Esc + d : delete from cursor position to end of the word
   Esc + f : move forward a word
   Esc + b : move backward a word
   Esc + t : transpose two adjacent words
ERSTELLUNG VON SKRIPTEN

ESSENTIAL TEMPLATE

#!/usr/bin/bash
# This script ...

LANG=C          # avoid errors due to localized command output
set -o nounset  # avoid using non initialised variables (rm -rf /$dir)
set -o errexit  # exit the script at non-true return value
set -o pipefail # catch errors from all parts of shell pipes
FULL TEMPLATE

siehe hier

SNIPPETS

swap stderr and stdout
myscript.sh 2>/dev/null 3>&2 2>&1 1>&3
print human number
bytestohuman() {
    # converts a NUMBER to a human readable format in IEC binary notation
    # (base-1024), rounded to DIGITS decimal places for anything larger than a
    # byte. switchable to PADDED format and BASE-1000 if desired.
    local NUMBER=${1:-0}     # input number
    local PADDED=${2:-yes}      # padding on (yes) or off (no)
    local BASE=${3:-1024}    # 2^x base: put 1024 or 1000 here
    local DIGITS=${4:-2}     # number of digits to put after "."

    awk -v bytes=$NUMBER -v pad=$PADDED -v base=$BASE -v digits=$DIGITS '
        function human(x, pad, base, digits) {
            if(base!=1024)base=1000
            basesuf=(base==1024)?"iB":"B"
            s="BKMGTEPYZ"
            while (x>=base && length(s)>1) {
                x/=base
                s=substr(s,2)
            }
            s=substr(s,1,1)
            xf=(pad=="yes") ? ("%"5+digits"."digits"f") : ("%."digits"f")
            s=(s!="B") ? (s basesuf) : ((pad=="no") ? s : ((basesuf=="iB")?(s "  "):(s " ")))
            return sprintf( (xf " %s"), x, s)
        }
        BEGIN{
            print human(bytes, pad, base, digits)
        }
    '
}
Random number generation
simple: 0 ... 32000:
echo $(( $RANDOM%100 ))
complex: signed 16-bit integer, limited random distribution due to use of modulo
random(){
    # generate good random number from /dev/urandom in the range
    # $offset ... (offset + $range)
    local range=${1:-1}
    local offset=${2:-0}
    local random=$(od -t uI -N 4 /dev/urandom | awk '{print $2}')
    echo $(( $random%($range+1) + $offset))
}
awk script integration: here doc os not working, handle parameters and script call like:
    awk -v bytes=$NUMBER -v pad=$PADDED -v base=$BASE -v digits=$DIGITS '
        function human(x, pad, base, digits) {
            ...
        }
        BEGIN{
            print human(bytes, pad, base, digits)
        }
    '
Array handling
arr=()
arr=("${arr[@]}" "new value1")
arr=("${arr[@]}" "new value2")
echo ${arr[@]}
echo ${arr[1]}
get random number in range 0...$MAX  (sh compatible, for bash use $RANDOM % $MAX)
        local Random=$(dd if=/dev/urandom count=1 2> /dev/null | cksum | cut -d ' ' -f1)
        echo $(( $Random % $MAX ))


uptime in seconds
BootEpochSeconds=$( date --date "$(uptime -s)" +%s )  # 2014-12-11 15:19:59
NowEpochSeconds=$( date +%s )
UptimeSeconds=$(( $NowEpochSeconds - $BootEpochSeconds  )) # thats it
check if string is positive integer (sh compatible)
# replaces any digit in the value of $i with an empty string, then -z-Test
test -z "${i//[0-9]}"


create dir, set permissions
    echolog "Checking dir and permissions for \"$Path\""
    install --owner $Owner --group $Group --mode 0750 --directory "$Path"


get value for config file parameter, strip comments and whitespace efficiently
function get_config_parameter() { # retrieve single parameter from config file
    local PARAM="$1"
    local FILE="$2"

        # sed: filter PARAM line, remove comments, strip "xxx=",
        # remove surrounding  whitespaces and quotes
        sed -e "/^\s*$PARAM\s*=/!d"                         \
            -e 's/#.*$//'                                   \
            -e 's/[^=]*=\s*\(.*\)\s*$/\1/' -e 's/\s*$//'    \
            -e 's/^"//' -e 's/"$//' -e "s/^'//" -e "s/'$//" \
            "$FILE"
}


example config file content:
  # param = value1
    param = value2 # some comment


example usage:
get_config_param "param" "config_file"
# returns: value2


convert rfc config file to bash source-able file
    # sed explained:
    #   -e remove whitespace followed by comment
    #   -e remove empty lines
    #   -e remove whitespace around "="
    #   -e remove whitespace before "="
    #   -e concentate lists: "aa, bb  ,  wewew, we' > aa,bb,wewew,we
    sed -e 's/\s*#.*$//'    \
        -e '/^$/d'          \
        -e 's/^\s*\([^=]*\)=\s*\(.*\)\s*$/\1=\2/' \
        -e 's/\s*=/=/'      \
        -e 's|\s*,\s*|,|g'  \
        "$CONFIG_FILE"


Check if array contains data
# Returns TRUE if argument 1 is part of the given array (remaining arguments)
function ElementIn () {
 local element
 for element in "${@:2}"; do [[ "$element" == "$1" ]] && return 0; done
 return 1
}


RDP Dateien lesen ... diese sind Little-endian UTF-16 codiert, Konvertierung in utf-8 per
iconv -f utf-16 -t us-ascii $RDP_FILE > $RDP_FILE.utf8
GPT Partitionsschema entfernen
dd if=/dev/zero of=$DRIVE bs=512 count=2
# find end of disk in blocks
seek_block=$(($(blockdev --getsz $DRIVE) - 2)) \
&& dd if=/dev/zero of=$DRIVE bs=512 count=2 seek=$seek_block
Check if string is a valid ipv4 ip
function is_ip() {
    if [ $(echo $1 | grep -o '\.' | wc -l) -ne 3 ]
    then
        return 1;
    elif [ $(echo $1 | tr '.' ' ' | wc -w) -ne 4 ]
    then
        return 1;
    else
        for OCTET in $(echo $1 | tr '.' ' '); do
            if ! [[ $OCTET =~ ^[0-9]+$ ]]; then
                    return 1;
            elif [[ $OCTET -lt 0 || $OCTET -gt 255 ]]; then
                    return 1;
            fi
        done
    fi
    return 0;
}
Convert 255.255.255.0 > 24
function mask2cdr () {    # Convert 255.255.255.0 to 24
   # Assumes there's no "255." after a non-255 byte in the mask
   set -- 0^^^128^192^224^240^248^252^254^ ${#1} ${1##*255.}
   set -- $(( ($2 - ${#3})*2 )) ${1%%${3%%.*}*}
   echo $(( $1 + (${#2}/4) ))
}
 convert 22 => 255.255.252.0
cidr2mask() {
  local i mask=""
  local full_octets=$(($1/8))
  local partial_octet=$(($1%8))
  for ((i=0;i<4;i+=1)); do
    if [ $i -lt $full_octets ]; then
      mask+=255
    elif [ $i -eq $full_octets ]; then
      mask+=$((256 - 2**(8-$partial_octet)))
    else
      mask+=0
    fi
    test $i -lt 3 && mask+=.
  done
  echo $mask
}
IP für eth0 ausgeben
get_ip () {
    ip a s eth0 \
    | grep -w inet \
    | awk '{print $2}' \
    | cut -d '/' -f 1
}
Netzmaske (z.Bsp. 24) für eth0 ausgeben
get_netmask_cidr () {
    ip a s eth0 \
    | grep -w inet \
    | awk '{print $2}' \
    | cut -d '/' -f 2
}
Netzmaske (255.255.252.0) für eth0 ausgeben
get_netmask() {
    cidr2mask $(get_netmask_cidr)
}
Kunden aus Netzwerk Konfig auslesen
get_customer() {
    grep "\.local\s" /etc/hosts \
    | grep -v puppet \
    | awk '{print $2}' \
    | cut -d '.' -f2
}
 #================================================================ 0. TOC ======#
#==============================================================================#


    1. variables
        1.1. arrays
        1.2. strings
        1.3. arithmetic
    2. regular expressions
    3. conditional structures
    4. loops
    5. execution, command line options
    6. piping
    7. file operations
    8. users and permissions
    9. system functions
        9.1. colors
        9.2. crontab
    10. templates
        10.1. functions
        10.2. script template
    11. networking

#========================================================== 1. Variables ======#
#==============================================================================#

# associative arrays, perl hashes, dynamic variable names
    # set:
    eval "homedir_$user=\"/home/$user\""
    # read:
    eval "echo \"varcontent='$'homedir_$user

    # replace variable definition in files with it's contents
        while read Line; do eval echo "$Line"; done < $FileIn > $Fileout


    export BRIDGES="3 4 5"; for i in $BRIDGES" ... geht nicht, i= "3 4 5"
        => funktionieren tut: export BRIDGES="3 4 5"; for i in `echo $BRIDGES`

    # Use variables' content as a variables name
        bla=55
        name=bla
        echo ${!name}

    # set a variable to default value in case source SVarName is empty
        VarName=${SVarName-default}        # not understood: try ":-" instead of "-"
    # set a variable to zero in case source SVar is not empty
    # check if variable has been defined/ set already (via error code)
        ${Name:?Meldung}    # exits programm when Name is not set, returns Meldung to stderr with row number in script
    # cut variables first or last part
        ${VarName##*/}          # everyting after last /
        ${VarName%/*}           # everythin before last /
        ${VarName##*.}          # strip off prefix (get extension)
        ${VarName/delme/}       # del "delme" from variable
        ${VarName//o/O}         # replace o by O
        ${rcfilesystems// /,}   # convert to comma-separated

        # remove last character of a line
        var=${var%?}
        # print last character
        echo ${a:$(( ${#a} -1 )):$(( ${#a} -1 ))}

        ${Name:-Ausdruck}   # returns ausdruck in case $Name is empty
        ${Name:+Ausdruck}   # returns ausdruck in case $Name is set to sth.

        ${#Name}            # length of variable $Name


        # example: replace file extensions $1=old ext $2= new ext
            mv FileName ${Filemame%$1}$2
    # slice variable  ${VarName:OffsetPosition:Length}
    slice_of_myvar=${myvar:3:2}

    # slice variable via read:
    ip=12.34.0.1; IFS="." read ipr; ${ipr[1]} is 34 (or read ip1 ip2 ip3 ip4)
    # or via set
    IFS="." set -- $IP; IP=${1}.${2}.${3}.${4}

    conditionals
    == # true if equal
    != # true if not equal



# get variables from config file
    PERMI="
        jaja xx cc gg
        no nö ach so
    "
    while read Line; do
     bla bla
    done < <( echo $Line )



    # get parameters  like par1 par2 par3 extra-par1 extra-par2 from full list
    # call like $ _get_list_parameters par1 par2 par3 extra-par1 extra-par2
    _get_list_parameters() {
        Files=""

        while [[ $# -gt 2 ]] ; do
            Files="$Files $1"
            shift
        done

        Owner=$1
        Perm=$2
    }




#=========================================================== 1.1. Arrays ======#


    # definition
        we[2]="hi"
        we[25]="ho"
    # call
        echo ${we[2]}
        echo ${we[@]}    # full array
        echo ${#we[@]}    # number of elements
    # math: ma[2]=3; ma[4]=5; ma[1]=`expr ${ma[2]} + ${ma[3]}` # let does not work, here
    # adding string to intger is not permitted


# suck a file into array file
   oIFS=$IFS IFS=$'\n' lines=($(<"$file")) IFS=$oIFS
   n=${#lines[@]}  # number of lines in text

# quickly assign data to array
    array=(one two three four)


#======================================================= 1.2. Arithmetic ======#


    # compare numbers
        -eq #    gleich
        -ne #    ungleich
        -gt #    gr▒▒er als
        -ge #    gr▒▒er gleich
        -lt #    kleiner als
        -le #    kleiner gleich
        <= >= < > # comparison

    # compare strings containing numbers
      if [ `eval echo $GroupID` -ge `eval echo $MinID` ] && \
         [ `eval echo $GroupID` -le `eval echo $MaxID` ]
      then

# idea of style guide: use a correct, maybe "best" versoin of different
# formulation possibilities
# if then  always use this form:
       # string comparison:
        [[ $foo = bar ]] with "[[ ]]"
        [[ bar = $foo ]] && [[ foo = $bar ]]
        [[ -n $var && -f $var ]] && echo "$var is a file"
        # arithmetic comparison:
        "(( $A > $B ))"   # sanitize your input aggressively (is_number)
# calculations (integer)
        echo $(( $A + $B ))

        (( a += $b )) #  a=$a+$b

    # All of the comparisons below are equivalent.
       # test "$a" -lt 16 && echo "yes, $a < 16"         # "and list"
       # /bin/test "$a" -lt 16 && echo "yes, $a < 16"
       # [ "$a" -lt 16 ] && echo "yes, $a < 16"
       # [[ $a -lt 16 ]] && echo "yes, $a < 16"          # Quoting variables within
        (( a < 16 )) && echo "yes, $a < 16"             # [[ ]] and (( )) not necessary.

        city="New York"
    # Again, all of the comparisons below are equivalent.
test "$city" \< Paris && echo "Yes, Paris is greater than $city"  # Greater ASCII order.
        /bin/test "$city" \< Paris && echo "Yes, Paris is greater than $city"
        [ "$city" \< Paris ] && echo "Yes, Paris is greater than $city"
        [[ $city < Paris ]] && echo "Yes, Paris is greater than $city"    # Need not quote $city.



    # operators (maybe zsh?)
        id++ id-- variable # post-increment and post-decrement
        ++id --id variable # pre-increment and pre-decrement
        ! ~ # logical and bitwise negation
        ** # exponentiation
        * / % # multiplication, division, remainder
        "<< >>" # left and right bitwise shifts
        & # bitwise AND
        ^ # bitwise exclusive OR
        | # bitwise OR
        &&, -a # logical AND
        ||, -o # logical OR
        expr ? expr : expr # conditional evaluation


    # numeric value of variables
        eval echo $VAR

    # calculate
        $(( VAR1 + VAR2 ))
        $[ VAR1 + VAR2 ]
        expr VAR1 + VAR2
        let a=VAR1+Var2  # shorties let "a += 1"; let "a -= 2" ; let "a /= 3"
        # +=; *=; /=; -=; <<=; >>=; ^=; |=

    # replacing empty variables
        VAR2=${VAR1:-DEFAULTVAL}
        if $VAR1 != "" then VAR2= $VAR1
            else VAR2= DEFAULTVAL
        fi

    #  Zahlen vergleichen mu▒t du -eq (== equal), -ge (>=greater equal), lt (< less than) nehmen

    # check if numeric:
    case $Var in
        *[!0-9.]*) echo "no var!";;
        *) echo "var" ;;
    esac

    # increment ((i++)) or (( i=i+23 ))
    # zsh array assignement: c=(lala bb ccc)  echo $c[2]

    # test if string is number
        # a=$(($1/$1)) > /dev/null 2>&1
            # [ $? = 0 ] && echo 1
           # call like



#========================================== 1.3. String, Texts, Globbing ======#

 str=ABC/DEF/xyz
 # remove from the right end (remove tail)
 echo ${str%/xyz}  # returns ABC/DEF
 echo ${str%/*}    # returns ABC/DEF (poor man's dirname)
 echo ${str%%/*}   # returns ABC (greedy)
 # remove from the left end (remove head)
 echo ${str#ABC/}  # returns DEF/xyz
 echo ${str#*/}    # returns DEF/xyz
 echo ${str##*/}   # returns xyz (poor man's basename) (greedy)
 # coole Sache! es werden auch Variablen ausgewertet...
 STRIP=/xyz
 echo ${str%$STRIP} # returns ABC/DEF
 # pick a part offs:len notation
 echo ${str:0:2}   # returns AB
 echo ${str:4:3}   # returns DEF

 # entfernen vom CR aus einem HTTP reply, damit das \r
 # nicht das Logfile 'unbrauchbar' macht...
 CR=$'\r'
 echo ${line%$CR}

# convert lower to upper case
    tr '[[:upper:]]' '[[:lower:]]'

#n sed like string replacement (see bash(1), ksh(1) for details)
 # ${parameter/pattern/string}  replace first occurence
 # ${parameter//pattern/string} replace all occurences
 echo $PWD             # /c/data/tramms/bin
 echo ${PWD/$HOME/\~}  # ~/bin
 safe a cat
 cut -d: -f1 < /etc/passwd | sort | xargs echo

  # cut lines 2,3 (display them)
  cut -d '
' -f 2,3


# replace and set variable contents
    function unset_feature {
       if [ ! -z ${1} ]; then
               FEATURES="${FEATURES/${1}/}"
       fi
    }

    function set_feature {
       if [ ! -z ${1} ]; then
               FEATURES="${FEATURES/${1}/} ${1}"
       fi


# insert first line to text
    echo $title | cat - $file >$file.new



isnumber() {
   # test if string is a valid number, use like
   # [ "`isnumber $2`" = "1" ] && echo number || echo no number

  ((  a = $1 / $1 )) > /dev/null 2>&1 || exit 1
  [ $? = 0 ] && echo 1
  # strange: program breaks here in case there was an error calculating
}






    # print numbers as a 10 -digit string (sort with "sort -n")
    printf %$MaxDigits.0f $NUMBER `
    # print text right - aligned with indent
    printf "%5s" text


    # string comparison
        $1 == $2 or $1 = $2
        $1 != $2
        -z $1      # true if $1 is empty (length = zero)
        ! -z $1 # other way round, do not use -n (buggy)
        $1 < $2  # lesser than $2 (ascii code)
        $1 > $2    # bigger than $2 (ascii code)


    # build config files from within a script
        cat >/etc/fstab <<EOF
    ..we.dewd..
        ^    .. ..
EOF

    # delete characters column-wise (col 2 and 4)
        colrm 2 4
    # delete columns 2 and 3 and paste after col 5 (example df)
        cut, paste, join # join is more flexibel than paste

    # check if single character is contained in string
        if [ ! `echo $@ | grep 'c' | wc -l` = 0 ]
        echo -n $Ports | sed 's/[^,]//g' | wc -c
    # counter
    wc -l    # lines
    sed ...
    wc -w # words
    wc -c # characters
    wc -L    # length of longest line

    # the better "echo": printf

    # replace single line in text
        # sed -i -e 's/^EDITOR/#EDITOR' -e 's/^#\(EDITOR=.\+vim"\)$/\1/' /etc/rc.conf
        # sed -i -e 's/^USE="\(.\+\)"$/USE="\1 -gpm"/' /etc/make.conf

    # get index of first occurence of expression "23" in string $VarName
    `expr index $VarName 23`
    # string length
    `expr length $VarName`
    # substring
    `expr substr $VarName $Offset $Length`


    # read line 5 from text: sed -n '5p' $FILE;

    # read config file, separator TAB or SPACE (IFS="    | ")
     # IFS="    | " stripcat $1 | while read a b c; do echo $a.$b.$c; done

    # read text line by line, extract single parameters
      IFS=" |    " |    echo $Container | while read a b c d; do
         echo $a $b $c
      done

    while read first_name last_name junk; do
      ...
    done <<< 'Bob Smith 123 Main Street Elk Grove Iowa 123-555-6789'


    cat < <( echo $Nics  ) > $bernd


he read command modifies each line read, e.g. it removes all leading whitespace characters (blanks, tab characters). If that is not desired, the IFS variable has to be cleared
        OIFS=$IFS; IFS=
    while read line
    do
        echo "$line"
    done < "$file"
    IFS=$OIFS

      while read line; do
        other commands
    done < <(some command)

O=$IFS IFS=$'\n' arr=($(< myfile)) IFS=$O           # one array element per line
O=$IFS IFS=$'\n' arr=($(find . -type f)) IFS=$O     # works on a stream of data as well as a file



    # read larger file with awk since while works slow


    # read variable, extract single parameters
        #IFS=" |    " echo $Container read a b c d


    # display escape-charcters and ascii:
    echo $'\a'  or echo $'\f\266'    #, see ascii character tables for \NNN
        # \b backspace    # \f formfeed # \n newline # \v \t vertical, horiz tab

    # transform string containing whitespaces to list of single elements (prior
    # to using uniq and sort etc.)
    Services=`echo $ServicesToRestart | sed 's/[ \t]\+/\n/g' | sort | uniq`



# style guide
always use echo "$a", not echo $a
always check for errors from a cd command, cd "Dir" || exit 1
when cd'ing into directory is needed only short-termed, use sub shell
    (cd "$subdir" && whatever && ...) # after exiting (),script is back in cd -



#================================================ 2. Regular Expressions ======#
#==============================================================================#

# group expressions, e.g. (A AND B) OR C
    (0<n AND n<=10) OR n=-1

    if (( (n>0 && n<10) || n == -1 ))           # for string, use [[ ]]
        then echo "0 < $n < 10, or n==-1"
    fi

# keep grep from grepping itself
    grep [n]ame  => does'nt work with [g] but the idea is made clear


# bash builtin regexps:
    http://en.wikipedia.org/wiki/Bash#In-process_regular_expressions
    # example (bash3)
        if [[ $foo =~ ^[-+]?[0-9]+\(\.[0-9]+\)?$ ]]; then
            echo "'$foo' looks rather like a number"
        else
            echo "'$foo' doesn't look particularly numeric to me"
        fi
    # example (egrep)
        if echo "$foo" | egrep '^[-+]?[0-9]+(\.[0-9]+)?$' >/dev/null; then
            echo "'$foo' might be a number"
        else
            echo "'$foo' might not be a number"
        fi
    # the parentheses in the egrep regular expression don't require backslashes in front of them, whereas the ones in the bash3 command do.



# sed address expressions
sed '1d' # del first line
sed '1,3d' # del lines 1...3
.     ein beliebiges Zeichen
?     das Muster vor dem ? darf einmal oder gar nicht auftreten
*     das Muster darf beliebig oft oder gar nicht auftreten
+     das Muster darf beliebig oft, muss aber mindestens einmal auftreten
{n}     das Muster muss genau n-mal auftreten
{,n}     das Muster darf h▒chstens n-mal auftreten
{n,}     das Muster muss mindestens n-mal auftreten
{n,m}     das Muster muss mindestens n-mal und h▒chstens m-mal auftreten



# insert a blank character after each character
sed 's/./& /g'





# grep regular expressions
[A-Za-z]+  # Eine Reihe von Gro▒- und Kleinbuchstaben, zum Beispiel "Mustertext"
(ftp|http|https|mailto|news)://[^ >)]+    # Internet URLs, zum Beispiel "http://www.linux-user.de/"
[A-Za-z0-9._-]+@[[A-Za-z0-9.-]+]  # email adressen




# regexp f▒r Variablennamen: /\$[_\.A-Za-z0-9\-]*/

# strip stuff from config files:
  # remove "#" and empty lines; leading, tailing ' ' '\t'; empty lines;
  # combine ' ', '\t' to ' '; remove ' ', '\t' around =
  sed -e 's/\#.*//;/^$/d'   -e 's/^[ \t]*//;s/[ \t]*$//;/^$/d' \
  -e 's/[ \t]\+/ /g' -e 's/[ \t]*=[ \t]*/=/'  $ParDir/$File > $TmpDir/$File

    # strip off comments and empty lines, use in pipes
        sed -e 's/\#.*//;/^$/d' -e 's/^[ \t]*//;s/[ \t]*$//;/^$/d' -e 's/[ \t]\+/ /g' $1
      # remove "#..."; leading tab/space; trailing tab/space; empty lines;
        # combine mulitple tab/space to single space
    # fill in "noop" at  beginning of each line containing '='
        sed '/^[0-9a-zA-z_-]*=/!s/\(.\)/noop \1/' filename

# sed in bash - curiosities:
   # ADDRESS: sed -e /$VAR/\!d   <= needs \!d, '' or "" not allowed
   # SEARCH:  replace "...$":  sed -e 's/.*\\$//' <= \\$

# sed search expressions
    *                  # any character sequence without /, including nothing/ zero
    .               #    any single character except newline
    ?                    # zero or single occurence the preceding RE (used for single characters)
    +                    # one or more of the preceding RE
    ^/$                # begin/ end of line
    [abcd]?      # an abcd character followed by any single character
    [^abcd]?    # exception
    \                    # reverts special character $ # -
    \{ \}            # indicate number of occurences of preceding RE to match
                        [0-9]\{5}\ # exactly 5 digits

# sed replace expressions



#============================================================ 3. If Else ======#
#==============================================================================#


    # if - else
       # [ "$3" ="" ] && VAR=$dummy || VAR=$3

     #test -z `ifconfig | grep eth1` && echo ist nicht da || echo ist da


[[ -n $var && -f $var ]] && echo "$var is a file"



    #[ -r "$mailfolder" ] || { echo "Can not read $mailfolder" ; exit 1; }


    # if [ -f $FILE ]; then ; elif ; else ; fi
    if cmd
    then :
    else
        echo war wohl nix
    fi
    # if [ ! -x ./MAKEDEV ] ; then ; fi
    # if ((EUID == 0 )); then ; fi

    # case $TESTVARIABLE in
    #    red) echo "Stop" ;;
    #    yellow | ora*) echo "prepare";;
    #    default) echo "nix verst▒h"; break ;;
    #  esac

    # while true; do echo -n "yes or no: " && read -s -n 1 INPUT
    #     case $INPUT in
    #        [yY]*) echo "command"; break ;;
    #        [nN]*)     echo "Skipping"; break ;;
    #        q*) exit;; *) echo "bullshit! - again:" ;;
    #     esac
    # done
           #!/bin/bash
           #OPTIONS="Hello Quit"
           #select opt in $OPTIONS; do
           #    if [ "$opt" = "Quit" ]; then
           #     echo done
           #     exit
           #    elif [ "$opt" = "Hello" ]; then
           #     echo Hello World
           #    else
           #     clear
           #     echo bad option
           #    fi
           #done

    # check if variable is listed in longer string:
    # bad way:
        if ! printenv PATH | grep -q $kdepath ; then
    # much better (no subshells, no '!'
        case ":$PATH:" in
            *:"$kdepath":*)    ;;    # already present
            *)                # missing
                    ... do stuff here ...
                    ;;
        esac

        # BTW, that :$PATH: isn't some little known weird shell syntax, it's
        # just the $PATH with colons either side so that the pattern match on
        # *:$kdepath:* will work even if $kdepath is right at the front or back
        # of $PATH.



#============================================================== 4. Loops ======#
#==============================================================================#


    # while true; do; done

    # FILES="/etc/fstab /etc/make.conf"
    # for FILE in $FILES; do echo "$FILE /root/${FILE##*/}"; done
    for i in `seq 0 80`; do ... # same as for i in 0 1 2 3 4 ... 80; do
    # for (( n = 0; n < ${#backupDef[*]} ; n++ )); do
        # def=${backupDef[n]}
        # n+=2 counts in "2" steps

# style guide
    while loop sourcing input: no files descriptors, no sub-shell:
    while read line; do
        things
    done < input   # or < <( echo $a $b)


#======================================== 5. Script Execution, Arguments ======#
#==============================================================================#


# convert Unix (epoch) timestamps to human-readable values
    date -d "@1164128484"

# construct command line, dynamic arguments (via array)
    args=(-s "The subject" "$address")
    command "${args[@]}" extraarg



# process id vor given process
    pgrep init bash # kill: pkill bash

# redirect "time"'s output - The reason that 'time' needs special care for redirecting its output is one of those mysteries of the universe. The answer will probably be solved around the same time we find dark matter.
    # file redirection
    { time ls; } > /path/to/foo 2>&1  # style guide
    # variable redirection
    foo=$( { time ls; } 2>&1 )



# redirect the output of multiple commands at once (style guide)
    {
        date
        # some other command
        echo done
    } > messages.log 2>&1



# return value of a command in a variable
    var=$(command)      # stdout only; stderr remains uncaptured
    var=$(command 2>&1) # both stdout and stderr will be captured


# create a command from variables
    wrong: args="-s 'The subject' $address"
    works: args=(-s "The subject" "$address")

# command line arguments
    $0 # script path, better use [[ $0 = /* ]] && echo $0 || echo $PWD/$0
    $$ # PID, great for constructing temporary file names
    $! # PID of last job run in background
    $# # number of arguments
    $*/@ # all arguments w./ w.o. "" (intact, no expansion)
    $? # last exit code
    $- # flags passed to script
    shift # deletes $1 from $@, makes $2 => $1, leaves $0 unchanged

# get command line arguments after $9
    hallo=${12}

# set command line arguments
        set -- "hallo wer is denn das" #  $5=das

# check if shell is interactive
    if [[ $- != *i* ]] ; then
       # Shell is non-interactive.  Be done now!
       return
    fi

# prevent part of a script from beeing executed (safes typing 40x '#')
: <<DEBUGXXX
for file in *            # this is not executed, here document to dummy function :
do
 cat "$file"
done
DEBUGXXX

# test if process is still running (idea: signal 0 does not harm anybody)
    pid=$( pgrep bash )
    kill -0 $pid && echo "alive" || echo "dead"  # Is the process still alive?

# testing exit code
        if command; then
        ...
        fi
    # or
           command 1 \
        && command 2 \  # put the && in front, this is read from left to right!
        || command 3



# error handling

    (cmd3 || fail) | (cmd4 || fail) |  (cmd5 || fail)

    # mit trap
        function error
        {
            echo Error
            exit 1
        }
        trap error ERR
        # commands that may have non-zero exit follow

        # trap always considers last command's state in a c1|c2|c2 chain

# find/ kill/ process by name
    pgrep, pkill

    # prevent error when a null value from command line gets assigned
        VarVm=$1Vm # append an Vm to dummy Var
        Var=${VarVm/x/x/}

    # other bash variables
        IFS=[,|;| |    ] # internal field separator, defaults to white space
        $HOME # current users home dir
        $PWD    # present working directory
        $SECONDS # time the script has been running already
        $RANDOM # ?? 1...5 digit

    # interesting: xargs: cp * $1 is equal to  ls . | xargs -i -t cp ./{}  $1
    # subshell: (cmd1; cmd2) with local variables, parenthesis
    # anonymus function: {cmd1; cmd2}    curly braces,
        # used for i/o redirection from or to one block:
        {
        echo ...
        sed ...
        tralala
        heinz=1
        } > /var/lala.txt
        echo $heinz

    # read single char from input
    read -s -n 1 BootType

       This  example code reads a file all at once, and splits it into a list, with each
       line in the file corresponding to an element in the list:

              set fl [open /proc/meminfo]
              set data [read $fl]
              close $fl
              set lines [split $data \n]


# ensure that only one instance of a script is running at a time
 lockdir=/tmp/myscript.lock # need a directory or symbolic link, file doesn't work
     if mkdir "$lockdir"        # do not use -p, the error code is needed
     then
         echo >&2 "successfully acquired lock"

         # Remove lockdir when the script finishes, or when it receives a signal
         trap 'rm -rf "$lockdir"' 0    # remove directory when script finishes
         trap "exit 2" 1 2 3 15        # terminate script when receiving signal

         # Optionally create temporary files in this directory, because
         # they will be removed automatically:
         tmpfile=$lockdir/filelist

     else
         echo >&2 "cannot acquire lock, giving up on $lockdir"
         exit 0
     fi



    nohup         # keep a program running after user has logged off
    exec <cmd># in ascript: execute command, then exit script/shell
    script         # records user keystrokes of session to file

    # run processes parallel:
        (cmd1; cmd2)
        (cmd3; cmd4)
        wait # do not execute next commands until subshells finish

    # test shell script with:
        bash -x <script>

    # wert einer variablen ausf▒hren:
        LA="echo hi"
        eval $LA

    # embedd perl code in bash script
    perl -e `print "this is a perl command"`

    # Output of a command: $(command) or `command`, host=`cat /etc/hostname`

    # wait: sleep [seconds], -m = minutes, h= hours] etc

    # nice [cmd] [options]: set cmd priority, -n=-20=highest, -n=19=lowest

    # execute script jobs.list at a given time
    at 2pm January 15 < jobs.list
    batch 2pm January 15 < jobs.list # like at except waiting for system load to be < .8

    # Getting the return value of a program
        #cd /dada &> /dev/null
            #echo rv: $?

    # get system load: uptime

    # debugging: print out line number of script with set -vx at beginning of script

    # import file via . /FILE, hand over script name and pid:
        # . /usr/bin/scriptease $0 $$
        # CALLER="`whoami`[$2]`basename $1`"

# command line parser (simple)
    while [ -n "$1" ]; do
        case $1 in
            -h|--help)
                usage=1 ; break ;; # call help
            -f|--fuckyou|--fuckher)
                # variable opt_f is set
            fuck ;;
            -s|since) shift ; since=$1 ;; # -l takes an argument
            -s=*)    since="$1#-s=}";;
            --since=*)     since="$1#--since=}";;
            --) shift ; break;; # end of options
            -*) echo "error: no such option $1. -h for help"
                usage=1 ; break ;;
            *)  break;;
        esac
    shift
    done

    Rest=$1






    # how to deal with exit codes and error messages
    # see redirection in redirection section
        mount /boot &> /dev/null && echo "ok" || echo "scheisse"; echo "nur so"
        # "nur so" gets printed when either echo "ok" or echo "scheisse" had exit > 0
        mount /boot &> /dev/null && \
            echo "ok" || {echo "scheisse"; echo "nur so"}
        # "nur so" gets printed when mount /boot/ had exit > 0

        if mount /boot &> error.log
        then echo ok
        else
          echo "so ein mist"
            cat error.log
        fi




# exit with error message and syslog
 die() {
  echo
  logger -p user.err -t $CALLER -- ERROR: $@
  echo $Red"Error: "$Normal$@
  exit 1
}

# echo message, log to syslog, call echolog "message"
 echolog() {
  if [ "$1" = "" ]; then
   echo "call echolog \"message\" [facility.priority]"
   echo "sample facilities: auth, cron, daemon, lpr, mail, security"
   echo " user and local0 ... local7"
   echo "prios: debug<info<notice<warning<err<crit<alert<emerg"
   die "logging error: no message specified"
   fi
  echo $1
  logger -p user.info -t $CALLER -- INFO: $@
#echo "End: "`date` >> $0.log 2>&1
}



#============= turn over scripts: function defintitions behind main loop ======#

function load_functions() {
   sed --silent -e '/^\#FUNCTIONS$/,/^\#FUNCTIONS-END$/p' "$0" |
   sed -e '/^\#FUNCTIONS/d' > $bernd

   source $bernd

}

#prepare function section (anywhere in script) like:
#FUNCTIONS
echo lalala
#FUNCTIONS-END


#Vergisst man ein Programm im Hintergrund zu starten ("&" am Zeilenende), kann man mi####t Strg-z das Programm anhalten. Mit den Befehlen "fg" bzw. "bg" kann man das Programm im Vordergrund bzw. im Hintergrund weiterarbeiten lassen.

Trick: M▒chte man wissen, wann ein lang laufendes Programm sich beendet, kann man es mit Strg-z anhalten und dann mit folgendem Befehl wieder starten:

    fg ; while /bin/true; do echo -ne \\a; sleep 1; done


Nach dem das Programm beendet ist wird in einer Endlosschleife ein Piepger▒usch erzeugt.


#============================================= 6. Piping, Command Output ======#
#==============================================================================#



    # output to screen and into file, tee -a = append mode
        # cmd | tee -a xxx.log

    # feeding a list, or other data in a file, into a script:
        script < filelist > outputfile.txt
    # here document
        cat << EOF
        bla bli blub
EOF


        cat << 'EOF' # prevent variable expansion
        bla bli $blub
EOF

    # command output redirection
        # use /dev/null instead of log for dropping output
        # force redirection
            script >| log # use when noglobber variable is set or log already exists

        # redirect standart output to file , put script to background, 2nd line: append
            script > log &    # new file, > is the same as 1> or 1>>
            script >> log & # append
        # redirect standard output to stderr
            script >2&
        # redirect error output to standard out
            script 2> &1
        # redirect error output, put script to background
            script 2> log &
        # redirect standard and error output, put script to background
            script &> log & # oder
            script > log 2> &1 &
        # redirect output and keep pipe
            script &> | tee -a log.txt
        # note
            ls -yz >> command.log 2>&1
            #  Capture result of illegal options "yz" in file "command.log."
            #  Note, however, that the following does *not* give the same result
            ls -yz 2>&1 >> command.log
            #  Outputs an error message and does not write to file.
            #  If redirecting both stdout and stderr,
            #+ the order of the commands makes a difference.


    # tee ( borrowing an idea from the plumbing trade )
    cat file | sort | tee checkfile | uniq > sorted_uniq.txt

    # process output redirection (three processes: parallel! )
    sort -k 9 <(ls -l /bin) <(ls -l /usr/bin) <(ls -l /usr/local/bin)
    sort -r <(find test -type d -mount -atime -12  -print)


    # copy via tar (whole root partition, avoid copy of mounted systems (cd, /proc/kcore) with -l
    tar cljf - / | (cd /ziel ; tar xjf - )



#===================================================== 7. File Operation ======#
#==============================================================================#

# copy a directory with all files and subdirectories
    cp_dir  () { cd $1 && find . -print | cpio -pdmv "$2"; } # cp <src> dst>

# receate a directory hierarchy, without files
    find . -type d -print | cpio -pdmv "$dst"

# print the nth line of a file (quicker than sed -n ${n}p "$file" )
    sed -n "$n{p;q;}" "$file"





# compare files, get intersection and differences (man comm)
  # intersection of file1 and file2
  comm -12 <(sort file1) <(sort file2)
  # subtraction of file1 from file2
  comm -13 <(sort file1) <(sort file2)



# file tests
-e # file/ directory (entry) exists
-ef # two files are the same
-nt / -ot file1 is newer/ older than file 2

# expand wildcards in command line, process each single file
    for File in $@
    do
        echo $File
    done

# copy, link files:
    cp -d ... ... : copy symlink as link
    cp -L ... ... : copy symlink's target to target



# file name in loops
    - do not ! use "for file in `ls -1 $Dir`",
            much better: "file in ./*" or "file in ./*.mp3" whatever
    - allways quote filename variables "$file"



# check if two files have the same inode (very slow procedure)
    [ `ls -i1 $SourceFile | cut -d' ' -f1` = `ls -i1 $TargetFile | cut -d' ' -f1` ] && continue
# better with find (man find)

# read where a symbolik links points to
    readlink <link>
# transform relative path to an absolute one:
    readlink -f <relative path>

# clear file
    > filename



# Extract filename from given full path
   f_name() { (echo ${1##*/}) }

# Extract pathname from given full path
   f_path() { (echo ${1%/*}) }

# Extract extension from given full path
   f_ext()  { (echo ${1##*.}) }




# display modification date of given single file or directory
 f_mdate() {
 echo `ls -dak --full-time $1 | awk '{print $6" "$7}' | cut -d. -f1`
}

# display last-access date of given single file or directory
 f_adate() {
 echo `ls -dauk --full-time $1 | awk '{print $6" "$7}' | cut -d. -f1`
}

# display file age of given file or directory (in days)
# 0 means today, 2 means 2 days ago
 file_age()   {
  FILE_TIME=`file_mdate $1`
  #echo $1 ____  $FILE_TIME
  AGE_SECONDS=$(( `date +%s` - `date -d "$FILE_TIME" +%s` ))
  echo $(( $AGE_SECONDS / 60 / 60 / 24 ))
}








# version control: 2006-05-30 = `date --iso`

    # conditions
        -a file # True if file exists.
        -d file # True if file exists and is a directory.
        -f file # True if file exists and is a regular file.
        -h file # True if file exists and is a symbolic link.
        -r file # True if file exists and is readable.
        -s file # True if file exists and has a size greater than zero.
        -w file # True if file exists and is writable.
        -x file # True if file exists and is executable.
        -O file # True if file exists and is owned by the effective user id.
        -G file # True if file exists and is owned by the effective group id.
        -S file # True if file exists and is a socket.
        -N file # True if file has been modified since it was last read
        file1 -nt/-ot file2 # Modification date1 newer/ older date2
        file1 -ef file2 # file1 and file 2 have the same device and inode numbers

    # check if directory is empty
        [ `ls -1a | wc -l` -gt 2 ] && echo "empty"

    # file comparison
        diff file1 file2 > differences.txt
        comm <options> file1 file2 > differences.txt # more options

    # copy complete partition, speed depending on bs
        dd bs=2048 if=/dev/hda1 of=/dev/hdb1

    # remove files older than 30 days
        find -name "$1.bak*" -maxdepth 1 -atime +30 -exec rm -vf {} \;
    # display only
        find -type f -mount -atime +30 -print

    # File descriptors: see google adv-bash-scr-howto

    # delete every file in a list: cat list | xargs rm

    # */*.pdf all pdf files in all subdirectories of the current directory

    # basename $FILE  = FILE
    # dirname $FILE  = PATH

    # Take arguments from file
        # FILELIST=/root/linkslist
        # for FILE in `grep -v ^# $FILELIST | awk '{print $1}'`; do
        # echo "$FILE /root/${FILE##*/}"
        # done

    # remove DOS ^M at EOL
        # tr -d '\r'

    # file permissions: 4=r 5=rx 6=rw 7=rwx / 660 = user, group, others




    is_net_fs() { # <path>
                  # return 0 if path is the mountpoint of a networked filesystem

        local path=$1
        local fstype
        [[ -z $NET_FS_LIST ]] && \
        NET_FS_LIST="afs cifs coda davfs fuse gfs ncpfs nfs nfs4 ocfs2 shfs smbfs"

        # /proc/mounts is always accurate but may not always be available
        if [[ -e /proc/mounts ]] ; then
            fstype="$( sed -n -e '/^rootfs/!s:.* '"$path"' \([^ ]*\).*:\1:p' /proc/mounts )"
        else
            fstype="$( mount | sed -n -e 's:.* on '"$path"' type \([^ ]*\).*:\1:p' )"
        fi
        [[ " ${NET_FS_LIST} " == *" ${fstype} "* ]]
        return $?
    }



    is_union_fs() { # <path>: return 0 if path is under unionfs control
        [[ ! -x /sbin/unionctl ]] && return 1
        unionctl "$1" --list &>/dev/null
    }







    # tune ext3 file system
        # umount /dev/hdxy
        # tune2fs -c 25 -i 2w -O dir_index /dev/hdxy
        # e2fsck -D /dev/hdxy

    # set permissions for home directories:
        # chmod a-rwx,u=rwVm -R USERDIR

    # bash: find old files (moved here 12 days ago)
        find /home/test -type f -mount -atime -12  -print
    # find old directories (moved here 12 days ago)
        find /home/test -type d -mount -atime -12  -print

    zsh
         print -l *(m+1) # lists files mod time older than one day
        print -l *(m-1) # lists files mod time younger than one day
        print -l *(a1)    # lists files with last access yesterday
        print -l *(@)     # lists links
        ls -doF *(/)        # lists directories, only
        chmod 640 *(W)  # changes permission only of all-writeable files
        grep name *(.)  # list files contents of all files in directory
        # find all directories recursively:
        ls -lR | grep '^\./' | #sed 's/^\.\///g' | sed 's/://g'


    # find files (recursively)
        # containing '.par '
        grep -rl '.par ' *

    # force filesystemcheck next reboot
    tune2fs -C 2000 /dev/hda5


     find . -mtime +0  # Dateien, die ▒lter  als 24 Stunden sind
    find . -mtime  0  # Dateien, die j▒nger als 24 Stunden sind
    find . -mtime -1  # Dateien, die vor weniger als 48 Stunden ge▒ndert wurden

#Dateien nach Zeitstempel sortieren (inkl. Unterverzeichnisse)
find . -printf '%TY-%Tm-%Td:%TT %p\n' | sort




# Falls der Plattenplatz knapp wird, und man wissen m▒chte welche Datei und welches Verzeichnis am meisten Platz ben▒tigt, kann folgende Zeile ausf▒hre. Diese Zeile erstellt eine Liste aller Verzeichnisse und Dateien sortiert nach Gr▒▒e. Falls die Platte (also in diesem Beispiel auch /var/tmp voll) ist, sollte man die Ausgaben ggf. per ssh zu einem anderen Rechner umleiten.

    du -ax / | sort -rn > /var/tmp/du-`date --iso`.log

    -x: Bleibe auf diesem Dateisystem. D.h. /proc wird ▒bersprungen.
    -a: Alle Dateien, nicht nur Verzeichnisse werden angegeben.

    sort -rn: Numerisch absteigend sortieren.


    Falls kein Platz mehr f▒r die Log-Ausgaben sind:

    root@plattevoll> du -ax / | ssh nutzer@woanders -C "sort -rn > /var/tmp/du-`date --iso`.log"





#============================================== 8. Users and Permissions ======#
#==============================================================================#


# umask seettings (used in fstab and bashrc)
   # umask 002 # relaxed   -rwxrwxr-x
   # umask 022 # cautious  -rwxr-xr-x
     umask 027 # uptight   -rwxr-x---
   # umask 077 # paranoid  -rwx------
   # umask 066 # bofh-like -rw-------

    # sed /etc/group for groups between 1000 and 1999
    sed '/.*:.*:1[0-9][0-9][0-9]/d' /etc/group


    # check if root is logged in
    (who|grep root > /dev/null 2>&1; if [  $? = 0 ]; then \
        date; echo -e "\n\tLucy logged in\n"; fi)

    # md5-crypt a clear - text password (for use in usermod)

         grub
         md5crypt ...
        # or
        pwcrypt < clear - text - passwd>
    w        # see who''s logged in and what he is doing:



#======================================== 9. System Functions, Variables ======#
#==============================================================================#


    uname -a     # full kernel, proc  and host info
    ulimit         # set limits on filesize etc
    uptime         # system up - time, along with logged users
    lld             # library dependancies for programm
    runlevel    # shows current runlevel
    netstat        # network status, ip -l
    lsmod, lsusb, lspci
    # get own ip: env LC_ALL=C /sbin/ifconfig eth0 | sed -n '/addr:/s/ [^r]*..//gp'



#=========================================================== 9.1. Colors ======#

SEE: tput


- Position the Cursor:
  \033[<L>;<C>H
     Or
  \033[<L>;<C>f
  puts the cursor at line L and column C.
- Move the cursor up N lines:
  \033[<N>A
- Move the cursor down N lines:
  \033[<N>B
- Move the cursor forward N columns:
  \033[<N>C
- Move the cursor backward N columns:
  \033[<N>D

- Clear the screen, move to (0,0):
  \033[2J
- Erase to end of line:
  \033[K

- Save cursor position:
  \033[s
- Restore cursor position:
  \033[u



# color defintions that work
        NO="\x1b[0;0m"
    BR="\x1b[0;01m"
    CY="\x1b[36;01m"
    RD="\x1b[31;01m"
    GR="\x1b[32;01m"
    YL="\x1b[33;01m"
    BL="\x1b[34;01m"




# Farbcodes Vordergrund
    \[\033[30m\] Schwarz
    \[\033[1;30m\] Dunkelgrau
    \[\033[31m\] Rot
    \[\033[1;31m\] Hellrot
    \[\033[32m\] Gr▒n
    \[\033[1;32m\] Hellgr▒n
    \[\033[33m\] Braun
    \[\033[1;33m\] Gelb
    \[\033[34m\] Blau
    \[\033[1;34m\] Hellblau
    \[\033[35m\] Dunkellila
    \[\033[1;35m\] Helllila
    \[\033[36m\] Dunkelt▒rkis
    \[\033[1;36m\] T▒rkis
    \[\033[37m\] Hellgrau
    \[\033[1;37m\] Weiss

# Farbcode Hintergrundfarbe
    \[\033[VmVmm\]    Keine Hintergrundfarbe
    \[\033[40;VmVmm\] Schwarz
    \[\033[41;VmVmm\] Rot
    \[\033[42;VmVmm\] Gr▒n
    \[\033[43;VmVmm\] Hellbraun
    \[\033[44;VmVmm\] Blau
    \[\033[45;VmVmm\] Lila
    \[\033[46;VmVmm\] T▒rkis
    \[\033[47;VmVmm\] Hellgrau



    Normal=$'\e[0;m'
    Bold=$'\e[1;3m'
    Underline=$'\e[4;3m'
    Flash=$'\e[5;3m'
    Reverse=$'\e[7,3m'
    Red=$'\e[31m'
    White=$'\e[38m'
    Yellow=$'\e[1;33m'
    Green=$'\e[32m'
    Blue=$'\e[34m'
    Purple=$'\e[35m'
    Fg=$'\e[39m'
    # example: echo "$Green$Bold Bye!$Purple lola $Normal$Underline hhhhh  "
    # or call directly (green)
    echo $'\e[1;36m'



#========================================================== 9.2. Crontab ======#


# crontab examples
        #SHELL=/bin/sh
        #PATH=/s newsrun-Kommando wird montags bis freitags von 8 bis 18 Uhr zu jeder vollen Stunde aufgerufen.

#        0 17 24 12 * echo %schoene Bescherung
#        Heiligabend um 17 Uhr, egal was f▒r ein Wochentag. Die Mitteilung wird per Mail an den Auftraggeber geschickt. In diesem Beispiel wird der Mitteilungstext nicht in der Kommandozeile an das echo-Kommando ▒bergeben, sondern in seinen Standardeingabekanal geschrieben.
#
#        0-59/5 * * * ~/bin/remind
#        Das remind-Kommando wird alle f▒nf Minuten aufgerufen, jeden Monat, jeden Tag, jede Stunde ...
#
#        0 6,10,14,18,22 * * * /usr/lib/uucp/uucico -s uucphost
#        Das uucico-Kommando wird t▒glich um 6, 10, 14, 18 und 22 Uhr auf- und damit der uucphost angerufen.
#
#        Ein bestimmter Tag kann sowohl als Monatstag als auch als Wochentag bestimmt werden. Wenn beide Felder bestimmt, also nicht durch einen Asterisk besetzt sind, werden sie durch eine logische ODER-Verkn▒pfung ausgewertet. Eine Warnung der Form
#
#        0 0-23 13 * fri wall %Achtung, Freitag der 13. *** FALSCH ***
#
#        w▒rde also jeden Freitag und jeden 13. eines Monats ausgegeben.
#
#        Umgebungsvariable in der crontab-Datei
        #MAILTO=root
    # Langwierige Jobs sollten besser Nachts ausgef▒hrt werden...
    # Um 21.00 Uhr soll die Warteschlange der Faxe bearbeitet und geleert werden
        # 0 21 * * *    root  test -x /usr/sbin/faxqclean && /usr/sbin/faxqclean
    # Reports ▒ber das Faxgeschehen sind um 23.25 Uhr zu generieren
        #25 23 * * *    root  test -e /usr/sbin/faxcron && sh /usr/sbin/faxcron |
        #mail FaxMaster

    # check scripts in cron.hourly, cron.daily, cron.weekly and cron.monthly
    #
    # Das n▒chste Kommando soll alle 15 Minuten starten und nicht protokolliert werden
        # -*/15 * * * *   root  test -x /usr/lib/cron/run-crons &&
        # /usr/lib/cron/run-crons
    # 0.00 Uhr jeden Tag
         #0 0  * * *     root  rm -f /var/cron/lastrun/cron.daily
    # 0.00 Uhr jeden Sonntag
         #0 0  * * 7     root  rm -f /var/cron/lastrun/cron.weekly
    # 0.00 Uhr jeden ersten Tag im Monat
         #0 0  1 * *     root  rm -f /var/cron/lastrun/cron.monthly
    # jeden ersten Montag
        # 14 * * * 1 [date "+%d" -le 7] && Programm


# vixie-cron - goodies: replace **1** - stuff by @reboot, @yearly, @midnight




#========================================================= 10. Templates ======#
#==============================================================================#



#======================================================= 10.1. Functions ======#

# one - liner
get_build() { if [ -z $BUILD_SOURCED ]; then . $BUILD_SOURCED; fi  ; }


# a function definition must precede the call
    function functionname {       # or functionname () {
    ...
    }
    # call functionname arg1 arg2; use them like $1 $2 in the function
    # all command line arguments are take literally (no variable names)
    # variables which should be lnown only within the function must be declared local ...
    return n # exits with exitcode n; otherwise the $? of the last command in function is taken



#=================================================== 10.2. script header ======#


#==============================================================================#
# Purpose:         *
#
# Usage:
#
#    History
#     06-    * Release
#-------------------------------------------------------------------------------
# Copyright Gunnar Mann, g.mann@mnx.eu
#    This program is free software; you can redistribute it and/or modify
#    it under the terms of the GNU General Public License as published by
#    the Free Software Foundation; either version 2 of the License, or
#    (at your option) any later version.
#
#    This program is distributed in the hope that it will be useful,
#    but WITHOUT ANY WARRANTY; without even the implied warranty of
#    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#    GNU General Public License for more details.
#
#    You should have received a copy of the GNU General Public License
#    along with this program; if not, write to the Free Software
#    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301
#
#==============================================================================#

usage ()
{
LastHistory=`sed -n '/Histo/{n;p;}' $0 | sed 'q' | sed 's/[# \t]*//g;s/\*.*//'`

cat << HELP
${0##*/} --
g.mann@mnx.eu $LastHistory

USAGE: ${0##*/} <>

<>
    .

EVmAMPLE: ${0##*/}

bye.
HELP
}

if [ $# -lt 1 ]
then
    usage
    exit 1
fi




#====================================================== zsh shell typing ======#
#==============================================================================#

# Press ESC,q to push cmd 1 into buffer, execute cmd 2, when command 2 is done, zsh will insert cmd 1 back
# short for less: # < readme.txt (zsh only)

# bash:
$_     #  letzte Argument des letzten Befehls (Bsp: mkdir beispiel; cd $_
ESC . oder ALT-. #  letzes Argument des letzen Befehles an Cursor einf▒gen
ESC n ESC . #  n-tes  Argement des letzen Befehlens an Crosorposition einf▒gen

# tip: statt tail -f  less +F verwende

start verz▒gern: sleep 1h  d s m

#========================================== ======#
#==============================================================================#


#======================================================== 11. networking ======#
#==============================================================================#



getip() {
   # getip <device> (eth0, br0)
   ip  addr | sed "/inet /!d;/${1}$/!d;s/\/.*//;s/[ \t]\+//g;s/inet//"
}

getmac() {
   # getmac <device> (eth0, br0)
   ip l | sed -n "/$1/{n;p;}" | awk '{print $2}'
}


# easy command line parser
    while [[ $1 == -* ]]; do
        case "$1" in
          -h|--help) show_help; exit 0;;
          -v) verbose=1; shift;;
          -f) output_file=$2; shift 2;;
        esac
    done
    # Now all of the remaining arguments are the filenames which followed
    # the optional switches.  You can process those with "for i" or "$@".

# copy ssh keys
    ssh-keygen -t dsa
    scp ~/.ssh/id_dsa.pub me@remote:
    ssh me@remote 'cat id_dsa.pub >> .ssh/authorized_keys'
    ssh me@remote date     # should not prompt for passWORD,
                           # but your key may have a passPHRASE
#!/bin/zsh
# linkmeto /bin/findreadme  root:root 755


# search for various types or README file in dir and display them in $PAGER
    files=(./(#i)*(read*me|lue*m(in|)ut)*(ND))
    if (($#files))
        then $PAGER $files
    else
        print 'No README files.'
    fi
