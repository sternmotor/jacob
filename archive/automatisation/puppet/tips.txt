# puppet stuff
notify { "Mac warning":
    
message => $operatingsystem ? {
        
'Darwin' => "This seems to be a
Mac.",
        
default => "And I’m a PC.",
    
},
}


Exec {
path => [
'/usr/local/bin',
'/opt/local/bin',
'/usr/bin',
'/usr/sbin',
'/bin',
'/sbin'],
logoutput => true,
}
exec {'pwd':}
exec {'whoami':}


## style hints
We recommend using single quotes for all strings that do not require variable interpolation. Use double quotes for those strings that require variable interpolation.

Code in those external manifests should always be stored in a class or defined resource type, or else it will be imported into the main scope and applied to all nodes.



## files
files and exec: see below

# create file
file{"$sqladm_cfg":
    ensure => file,
    owner => root,
    group => root,
    mode => 0444,
}



# create link

        file{ '/etc/apache2/conf.d/phpmyadmin.conf' :
            ensure => link
            target => '/etc/phpmyadmin/apache.conf',
        }


## variables
$content = 'some content\n'
file { '/tmp/testing': content => $content }

# a variable may only be assigned/changed once per scope

# reference to variables
    class myclass {
        $test = 'content'
    }

    class anotherclass {
        $other = $myclass::test
    }



## arrays

# TEMPLATES
# ----------- print array members as space-separated string
ip=<%= ips_public.flatten.join(' ') %>'

# ------------ iterate over array
<% hc_hosts.each do |hc_host| -%>
<%=  hc_host %>.<%= hc_domain %>    <%= hc_host -%>
<% end -%>

# ----------- iterate over associative array
# !!! There is no comma after last element of hash

    # host cluster members
    $hc_hosts = { 
        host1 => "$dmz.$id_host1",
        host2 => "$dmz.$id_host2"
    }

<% hc_hosts.each _pair do |hc_host, hc_host_ip | -%>
<%= hc_host_ip %>   <%=  hc_host %>.<%= hc_domain %>    <%= hc_host -%>
<% end -%>



# PUPPET SCRIPTS


# --------- sample usage

    define php::pear() {
      package { "php-${name}": ensure => installed }
    }

    php::pear { ['ldap', 'mysql', 'ps', 'snmp', 'sqlite', 'tidy', 'xmlrpc']: }



# ---------- appending to arrays !! scope is local to test, only!
   $ssh_users = [ 'myself', 'someone' ]

    class test {
       $ssh_users += ['someone_else']
    }

# ---------- iterate over array
if  you have an array like:
$array=[ "entry1", "entry2" ]

you can use it like:

define dosomething {
    # you will have your array element available here as $name
}

# use the define with your array
dosomething { $array } 
#----------


$a = [ 'one', 'two', 'three' ]
notice $a[1] # would return two



array of resource references [ Notify['look'], Notify['like'], Notify['this'] ]

    file { [ 'foo', 'bar', 'foobar' ]: # see class inheritance below
        owner => root,
        group => root,
        mode  => 600,
    }

    # call a custom defined resource multiple times
    define php::pear() {
        package { "`php-${name}": ensure => installed }
    }

    php::pear { ['ldap', 'mysql', 'ps', 'snmp', 'sqlite', 'tidy', 'xmlrpc']: }

## hashes
$myhash = { key1 => "myval", key2 => $b }

# And to access hash members (recursively) from a variable containing a hash (this also works for arrays too):
    $myhash = { key => { subkey => "b" }}
    notice($myhash[key][subkey]]
# You can also use a hash member as a resource title, as a default definition parameter, or potentially as the value of a resource parameter


## conditions
# "in"
    $value = 'beat generation'
    if 'eat' in $value {
      notice("on the road")
    }

# selector: returns value
    file { '/etc/config':
        owner => $operatingsystem ? {
            'sunos'   => 'adm',
            'redhat'  => 'bin',
            default   => undef,
        },
    }

    # or
    $owner = $operatingsystem ? {
        sunos   => 'adm',
        /(redhat|debian)/  => "$1",  # $1 = redhat or debian
        default => undef,
    }

  $virtarg = $paravirt ? {
        true => '--paravirt',
        false => '--hvm',
      }

# case: does not return value
    case $operatingsystem {
        sunos,debian:   { 
            include solaris
            include debian
        } 

        /^(r|f)edhat$/:  { notice{"Welcome $1!" }  } # apply the redhat class
        default: { include generic } # apply the generic class
    }


# if then
    if $server == 'mongrel' {
        include mongrel
    } elsif $server == 'nginx' {
        include nginx
    } else {
        include thin
    }


    if ( $processor_count > 2 ) and (( $ram >= 16 * $gigabyte ) or ( $disksize > 1000 )) {
        include for_big_irons
    } else {
        include for_small_box
    }

and, or and not, group by()
==, !=, <, >, <=, >, >=
+, -, /, *, <<, >>
=~ and !~ # regexp
# bool example
    $one = 1
    $two = 2
    $var = ( $one < $two ) and ( $one + 1 == $two )
# regexp example
    if $host =~ /^www(\d+)\./ {
        notice('Welcome web server #$1')  # $1 = number following www
    }



## virtual ressources
Virtual resources are resources that are not sent to the client unless realized

@user { luke: ensure => present } # defined virtually
realize User[luke]         # relaized a): the user whose title is luke
User <| title == luke |>          # relaized b): the user whose title is luke

# exporting ressources, tags
# see http://docs.puppetlabs.com/guides/exported_resources.html
node a {
    @@file { "/tmp/foo": content => "fjskfjs\n", tag => "foofile", }
}
node b {
    File <<| tag == 'foofile' |>>
}

# debugging

log to master log:
notice("The value is: ${yourvar}")


log to agent's syslog:
notify{"The value is: ${yourvar}": }


puppetd --test --environment=development --debug | tee /tmp/puppet-debug.log
less /tmp/puppet-debug.log


# module import
include foo::bar               # {modulepath}/foo/manifests/bar.pp  class foo::bar
class { "foo::bar::awesome": } # {modulepath}/foo/manifests/bar/awesome.pp class foo::bar::awesome { ... }


# Run a Command Whenever A File Changes
file { "/etc/bind": source => "/dist/apps/bind" }


exec { '/usr/bin/ndc reload':
  subscribe => File['/etc/bind'],
  refreshonly => true,
}


# class parameters

    node webserver {
      class { apache: version => "1.3.13" }
    }

    class apache($version="1.3.13",$home="/var/www") {
      ... class contents ...
    }

## class inheritance/ vererbung
    class unix {
        file { '/etc/passwd':
             owner => 'root',
             group => 'root',
             mode  => 644;
        }
    }
class freebsd inherits unix {
        File['/etc/passwd'] { group => wheel }
    }

# undo i
    class apache($version) {
      ... class contents ...
    }
  node webserver {
      class { apache: version => "1.3.13" }
    }


    # default parameters
  class apache($version="1.3.13",$home="/var/www") {
      ... class contents ...
    }


## regexps, nodes
node /^(foo|bar)\.testing\.com$/ {
node 'www.testing.com', 'www2.testing.com', 'www3.testing.com' {

## regexp, slector
$owner = $operatingsystem ? {
    /(redhat|debian)/  => 'bin',
    default => undev
}

## package relation ships, notifying 
File["/etc/ntp.conf"] ~> Service[ntpd]
# This manages the ntp configuration file before the ntpd service and notifies the service of changes to the ntp configuration file.



## package/file/service pattern
    # /root/learning-manifests/break_ssh.pp
    package { 'openssh-server':
        ensure => present,
        before => File['/etc/ssh/sshd_config'],
    }
    
    file { '/etc/ssh/sshd_config':
        ensure => file,
        mode   => 600, 
        source => '/root/learning-manifests/sshd_config',
    }
        
    service { 'sshd':
        ensure     => running,
        enable     => true, 
        hasrestart => true,
        hasstatus  => true,
        subscribe  => File['/etc/ssh/sshd_config'],
    }
# defines
               define testy ($tex) {
                       notify { $tex: }
               }
                testy { "test" : tex => "hallo" }






FEHLER

Error 400 on SERVER: undefined method `safeevaluate' for nil:NilClass
passiert wenn eine define anweisung innerhalb einer case loop kommt, ohne case loop gehts und wenn die define anweisung innerhalb einer class gekapselt wird auch


# enable boot logger bootlogd
cat << BOOT_LOG_END > /etc/default/bootlogd || die
# Run bootlogd at startup ?
BOOTLOGD_ENABLE=Yes
BOOT_LOG_END


# file system permissions
    echo " * file system permissions ... "
    install -d $TargetDir/tmp     --mode 1777
    install -d $TargetDir/var/tmp --mode 1777
    install -d $TargetDir/        --mode 0755
    install -d $TargetDir/etc     --mode 0755
    install -d $TargetDir/var/log --mode 0755
    install -d $TargetDir/root    --mode 0750
    install -d $TargetDir/boot    --mode 0750
    chmod 0440 $TargetDir/etc/sudoers
    chmod 0644 $TargetDir/etc/passwd    $TargetDir/etc/group  $TargetDir/etc/profile
    chmod 0600 $TargetDir/etc/passwd-   $TargetDir/etc/group- $TargetDir/etc/shadow
    chmod 0600 $TargetDir/etc/securetty $TargetDir/etc/shadow-


# set up production state flag (productive/test/other system)
$TargetDir/etc/prod_system
$TargetDir/etc/test_system
$TargetDir/etc/test_system



# syntax 

  include firewall::server
  
  firewall::input-port {
      "portmap-tcp": dport => "111";
      "portmap-udp": dport => "111", protocol => "udp";
      "nfs-tcp": dport => "2049";
      "nfs-udp": dport => "2049", protocol => "udp";
      "lockd-tcp": dport => "48620";
      "lockd-udp": dport => "48620", protocol => "udp";
      "mountd-tcp": dport => "48621";
      "mountd-udp": dport => "48621", protocol => "udp";
      "statd-tcp": dport => "48622";
      "statd-udp": dport => "48622", protocol => "udp";
      "rquotad-tcp": dport => "48623";
      "rquotad-udp": dport => "48623", protocol => "udp";
  }




#  echo -n " * copying host system's modules to target vm ... "
                    rsync -a --delete "$modules_dir/" "$TargetDir/$modules_dir" && \
                    chroot "$TargetDir" depmod -a && pass || die



# device nodes
    echo " * (re)create important devices nodes ... "

    chroot $TargetDir mknod /dev/null    c 1  3                || :
    chroot $TargetDir mknod /dev/zero    c 1  5                || :
    chroot $TargetDir mknod /dev/systty  c 4  0                || :
    chroot $TargetDir mknod /dev/tty     c 5  0                || :
    chroot $TargetDir mknod /dev/console c 5  1                || :
    chroot $TargetDir mknod /dev/ptmx    c 5  2                || :
    chroot $TargetDir mknod /dev/rtc     c 10 135              || :
    chroot $TargetDir mknod /dev/ttyS0   -m 600 c 4  64        || :
    chroot $TargetDir mknod /dev/ttyS1   -m 600 c 4  65        || :
    chroot $TargetDir mknod /dev/ttyS2   -m 600 c 4  66        || :
    chroot $TargetDir mknod /dev/ttyS3   -m 600 c 4  67        || :
    install -d $TargetDir/dev/net -m 0750                      || :
    chroot $TargetDir mknod -m 600 /dev/net/tun c 10 200       || :
    chroot $TargetDir mknod -m 644 /dev/random c 1 8           || :
    chroot $TargetDir mknod -m 644 /dev/urandom c 1 9          || :
    chroot $TargetDir mknod /dev/psaux -m 644 c 10 1           || :

    for TTY in 0 1 2 3 4 5 6 7 8 9 10 11 12; do
        chroot $TargetDir mknod /dev/tty$TTY -m 600 c 4 $TTY   || :
        chroot $TargetDir chown root:tty /dev/tty$TTY
    done


define device_node($type="c",$major,$minor,$mode) {
  exec { "create-device-${name}":
    command => "[ -f ${name} ] && rm -f ${name} && mknod -m ${mode}
${name} ${type} ${major} ${minor} || mknod -m ${mode} ${name} ${type}
${major} ${minor}" ,
    path => "/bin",
    creates => $name,
  }

}

Would let you then call:

device_node { "/var/chroot/dev/urandom":
  type => c,
  major => 1
  minor => 9
  mode => 0444

} 



# define stuff
define add_user ( $email, $uid ) {

            $username = $title
...
}

    add_user { rrunner:
            email    => "road.runner@acme.com",
            uid      => 5001
    }



# drbd morory usage
> There have been lately some very good threads about DRBD memory usage.
> I'd like to ask if, after this, my understanding about the total memory
> usage is correct.
> 
> If I understand correctly, we have:
>   - per-TB 32MB of memory used, statically, independent of over how many
>     DRBD minors it is spread
>   - a per-minor usage of up to:
>     - sndbuf-size for the TCP connection (can be ignored)
>     - PAGE_SIZE * max_buffers
>     - probably some other small values (kernel structures or such) which
>       can be ignored for normal cases
> 
> This means, a 1TB device with the defaults of sndbuf-size 132KB and
> max_buffers 2048 will use (at max, e.g. during resync):
>   - 32MB for bitmap
>   - 132KB for TCP connection
>   - 8MB for the buffers
> 
> I.e. this is ~40MB.
> 
> On the other hand, a 1TB device split over 8 x 128MB, will have 32MB +
> 8x8MB =~ 96MB.

the max-buffer setting limits the abount of in-flight data.
if nothing is in-flight, no such buffers are allocated.
if something is in-flight, these are allocated on the receiving side
to be able to submit it to the block device.

so "up to" max-buffers on the receiving side,
which on the sending side corresponds to
that many dirty (write-out) pages,
or to pages read in by the resync process.

we also have a small number of mempools, and a page pool emergency
reserve to not stall during write-out caused by hard memory pressure.


# drbd syncer rate (MB/s)
Tip

A good rule of thumb for this value is to use about 30% of the available replication bandwidth. Thus, if you had an I/O subsystem capable of sustaining write throughput of 180MB/s, and a Gigabit Ethernet network capable of sustaining 110 MB/s network throughput (the network being the bottleneck), you would calculate:

Equation 6.1. Syncer rate example, 110MB/s effective available bandwidth
0.3*110

Thus, the recommended value for the rate option would be 33M.

By contrast, if you had an I/O subsystem with a maximum throughput of 80MB/s and a Gigabit Ethernet connection (the I/O subsystem being the bottleneck), you would calculate:
0.3*80=24
Equation 6.2. Syncer rate example, 80MB/s effective available bandwidth


In this case, the recommended value for the rate option would be 24M. 

# increase sync rate temporarily
drbdsetup /dev/drbdnum syncer -r 110M
# restore
drbdadm adjust resource




# edit single line in file (add line if not exists)
# see http://projects.puppetlabs.com/projects/1/wiki/Simple_Text_Patterns

define line($file, $line, $ensure = 'present') {
    case $ensure {
        default : { err ( "unknown ensure value ${ensure}" ) }
        present: {
            exec { "/bin/echo '${line}' >> '${file}'":
                unless => "/bin/grep -qFx '${line}' '${file}'"
            }
        }
        absent: {
            exec { "/bin/grep -vFx '${line}' '${file}' | /usr/bin/tee '${file}' > /dev/null 2>&1":
              onlyif => "/bin/grep -qFx '${line}' '${file}'"
            }

            # Use this resource instead if your platform's grep doesn't support -vFx;
            # note that this command has been known to have problems with lines containing quotes.
            # exec { "/usr/bin/perl -ni -e 'print unless /\Q${line}\\E\$/' '${file}'":
            #     onlyif => "/bin/grep -qFx '${line}' '${file}'"
            # }
        }
    }
}


# Usage example: Add ‘dummy’ to the list of automatically loaded modules
file { "/etc/modules": ensure => present, }

line { dummy_module:
    file => "/etc/modules",
    line => "dummy",
}

# Usage example: Remove ‘dummy’ from the list of automatically loaded modules
file { "/etc/modules": ensure => present, }

line { dummy_module:
    file => "/etc/modules",
    line => "dummy",
    ensure => absent
}

# comment a line in file
uncomment: {
    exec { "/bin/sed -i -e'/${line}/s/#\+//' ‘${file}’” :
        onlyif => "/bin/grep '${line}' '${file}' | /bin/grep '^#' | /usr/bin/wc -l"
    }
}
comment: {
    exec { "/bin/sed -i -e'/${line}/s/\(.\+\)$/#\1/' ‘${file}’" :
        onlyif => "/usr/bin/test `/bin/grep '${line}' '${file}' | /bin/grep -v '^#' | /usr/bin/wc -l` -ne 0"
    }
}

# Usage example (activate logsentry with vixie-cron):
line { "logsentrycron":
    file => "/etc/cron.hourly/logsentry.cron",
    line => "logcheck.sh",
    ensure => uncomment
}
